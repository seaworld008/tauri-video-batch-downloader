   Compiling video-downloader-pro v1.0.0 (D:\develop-file\2-python-dev\03-video-downloader-tauri\video-downloader-tauri\src-tauri)
warning: unused imports: `Cursor`, `PathBuf`, and `SeekFrom`
  --> src\core\file_parser.rs:26:30
   |
26 |     io::{BufRead, BufReader, Cursor, Read, Seek, SeekFrom},
   |                              ^^^^^^              ^^^^^^^^
27 |     path::{Path, PathBuf},
   |                  ^^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

warning: unused import: `self`
  --> src\core\integrity_checker.rs:10:15
   |
10 | use std::io::{self, BufReader, Read};
   |               ^^^^

warning: unused import: `sleep`
   --> src\core\integrity_checker.rs:722:23
    |
722 |     use tokio::time::{sleep, Duration};
    |                       ^^^^^

warning: unused import: `Context`
  --> src\core\m3u8_downloader.rs:11:28
   |
11 | use anyhow::{anyhow, bail, Context, Result};
   |                            ^^^^^^^

warning: unused import: `regex::Regex`
  --> src\core\m3u8_downloader.rs:15:5
   |
15 | use regex::Regex;
   |     ^^^^^^^^^^^^

warning: unused import: `BufReader`
  --> src\core\m3u8_downloader.rs:27:46
   |
27 | use tokio::io::{AsyncReadExt, AsyncWriteExt, BufReader};
   |                                              ^^^^^^^^^

warning: unused import: `uuid::Uuid`
  --> src\core\m3u8_downloader.rs:30:5
   |
30 | use uuid::Uuid;
   |     ^^^^^^^^^^

warning: unused import: `crate::core::models::*`
  --> src\core\m3u8_downloader.rs:33:5
   |
33 | use crate::core::models::*;
   |     ^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `RwLock`
 --> src\core\manager.rs:9:32
  |
9 | use tokio::sync::{mpsc, Mutex, RwLock};
  |                                ^^^^^^

warning: unused import: `System`
  --> src\core\monitoring.rs:18:44
   |
18 | use sysinfo::{CpuExt, DiskExt, NetworkExt, System, SystemExt};
   |                                            ^^^^^^

warning: unused import: `sleep`
  --> src\core\monitoring.rs:20:29
   |
20 | use tokio::time::{interval, sleep};
   |                             ^^^^^

warning: unused imports: `AppError` and `TaskStatus`
  --> src\core\monitoring.rs:25:27
   |
25 | use crate::core::models::{AppError, AppResult, TaskStatus};
   |                           ^^^^^^^^             ^^^^^^^^^^

warning: unnecessary parentheses around assigned value
   --> src\core\monitoring.rs:696:26
    |
696 |             disk_used += (disk.total_space() - disk.available_space());
    |                          ^                                           ^
    |
    = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
    |
696 -             disk_used += (disk.total_space() - disk.available_space());
696 +             disk_used += disk.total_space() - disk.available_space();
    |

warning: unused import: `Duration`
  --> src\core\progress_tracker.rs:10:17
   |
10 | use std::time::{Duration, Instant};
   |                 ^^^^^^^^

warning: unused import: `error`
  --> src\core\progress_tracker.rs:12:22
   |
12 | use tracing::{debug, error, info, warn};
   |                      ^^^^^

warning: unused import: `AppError`
  --> src\core\progress_tracker.rs:14:27
   |
14 | use crate::core::models::{AppError, AppResult};
   |                           ^^^^^^^^

warning: unused import: `Response`
  --> src\core\resume_downloader.rs:12:23
   |
12 | use reqwest::{Client, Response, StatusCode};
   |                       ^^^^^^^^

warning: unused imports: `AtomicU64` and `Ordering`
  --> src\core\resume_downloader.rs:17:26
   |
17 |     atomic::{AtomicBool, AtomicU64, Ordering},
   |                          ^^^^^^^^^  ^^^^^^^^

warning: unused imports: `Instant` and `UNIX_EPOCH`
  --> src\core\resume_downloader.rs:20:27
   |
20 | use std::time::{Duration, Instant, SystemTime, UNIX_EPOCH};
   |                           ^^^^^^^              ^^^^^^^^^^

warning: unused import: `Mutex`
  --> src\core\resume_downloader.rs:23:19
   |
23 | use tokio::sync::{Mutex, RwLock};
   |                   ^^^^^

warning: unused import: `uuid::Uuid`
  --> src\core\resume_downloader.rs:24:5
   |
24 | use uuid::Uuid;
   |     ^^^^^^^^^^

warning: unused import: `crate::core::models::TaskStatus`
  --> src\core\resume_downloader.rs:27:5
   |
27 | use crate::core::models::TaskStatus;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `error` and `warn`
  --> src\core\youtube_downloader.rs:12:22
   |
12 | use tracing::{debug, error, info, warn};
   |                      ^^^^^        ^^^^

warning: unused import: `DownloadEvent`
 --> src\core\manager_test.rs:7:33
  |
7 |     use super::super::manager::{DownloadEvent, DownloadManager};
  |                                 ^^^^^^^^^^^^^

warning: unused import: `std::time::Duration`
 --> src\core\manager_test.rs:9:9
  |
9 |     use std::time::Duration;
  |         ^^^^^^^^^^^^^^^^^^^

warning: unused import: `tokio::time::timeout`
  --> src\core\manager_test.rs:10:9
   |
10 |     use tokio::time::timeout;
   |         ^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `AppError`, `AppResult`, `DownloadStats`, and `config::AppConfig`
  --> src\core\integration_tests.rs:7:9
   |
7  |         config::AppConfig,
   |         ^^^^^^^^^^^^^^^^^
...
10 |             AppError, AppResult, DownloadConfig, DownloadStats, DownloaderType, ProgressUpdate,
   |             ^^^^^^^^  ^^^^^^^^^                  ^^^^^^^^^^^^^

warning: unused import: `std::time::Duration`
  --> src\core\integration_tests.rs:15:9
   |
15 |     use std::time::Duration;
   |         ^^^^^^^^^^^^^^^^^^^

warning: unused import: `super::super::models::TaskStatus`
  --> src\core\resume_downloader_integration_tests.rs:12:9
   |
12 |     use super::super::models::TaskStatus;
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `uuid::Uuid`
  --> src\core\m3u8_integration_tests.rs:14:9
   |
14 |     use uuid::Uuid;
   |         ^^^^^^^^^^

warning: unused import: `calamine::DataType`
 --> src\core\file_parser_tests.rs:7:9
  |
7 |     use calamine::DataType;
  |         ^^^^^^^^^^^^^^^^^^

warning: unused import: `SHIFT_JIS`
  --> src\core\file_parser_tests.rs:10:53
   |
10 |     use encoding_rs::{BIG5, Encoding, GB18030, GBK, SHIFT_JIS, UTF_8};
   |                                                     ^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> src\core\file_parser_tests.rs:11:9
   |
11 |     use std::collections::HashMap;
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `tempdir`
  --> src\core\file_parser_tests.rs:13:20
   |
13 |     use tempfile::{tempdir, NamedTempFile};
   |                    ^^^^^^^

warning: unused import: `calamine::DataType`
  --> src\core\file_parser_integration_tests.rs:14:9
   |
14 |     use calamine::DataType;
   |         ^^^^^^^^^^^^^^^^^^

warning: unused import: `SHIFT_JIS`
  --> src\core\file_parser_integration_tests.rs:15:34
   |
15 |     use encoding_rs::{BIG5, GBK, SHIFT_JIS, UTF_8};
   |                                  ^^^^^^^^^

warning: unused import: `futures::future`
  --> src\core\file_parser_integration_tests.rs:16:9
   |
16 |     use futures::future;
   |         ^^^^^^^^^^^^^^^

warning: unused imports: `collections::HashMap`, `io::Write`, and `path::Path`
  --> src\core\file_parser_integration_tests.rs:17:15
   |
17 |     use std::{collections::HashMap, fs, io::Write, path::Path};
   |               ^^^^^^^^^^^^^^^^^^^^      ^^^^^^^^^  ^^^^^^^^^^

warning: unused import: `DownloadEvent`
 --> src\core\progress_tracker_integration_tests.rs:8:33
  |
8 |     use super::super::manager::{DownloadEvent, DownloadManager};
  |                                 ^^^^^^^^^^^^^

warning: unused imports: `TaskStatus` and `VideoTask`
 --> src\core\progress_tracker_integration_tests.rs:9:59
  |
9 |     use super::super::models::{AppResult, DownloadConfig, TaskStatus, VideoTask};
  |                                                           ^^^^^^^^^^  ^^^^^^^^^

warning: unused import: `EnhancedProgressStats`
  --> src\core\progress_tracker_integration_tests.rs:10:42
   |
10 |     use super::super::progress_tracker::{EnhancedProgressStats, ProgressTrackingManager};
   |                                          ^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::path::PathBuf`
  --> src\core\youtube_downloader_integration_tests.rs:12:9
   |
12 |     use std::path::PathBuf;
   |         ^^^^^^^^^^^^^^^^^^

warning: unused import: `anyhow::Result`
 --> src\utils\encoding.rs:5:5
  |
5 | use anyhow::Result;
  |     ^^^^^^^^^^^^^^

warning: unused import: `GB18030`
 --> src\utils\encoding.rs:6:29
  |
6 | use encoding_rs::{Encoding, GB18030, GBK, UTF_8};
  |                             ^^^^^^^

warning: unused import: `PathBuf`
 --> src\utils\file_utils.rs:5:23
  |
5 | use std::path::{Path, PathBuf};
  |                       ^^^^^^^

warning: unused variable: `app`
  --> src\commands\config.rs:17:25
   |
17 | pub async fn get_config(app: AppHandle, state: State<'_, AppState>) -> Result<AppConfig, String> {
   |                         ^^^ help: if this is intentional, prefix it with an underscore: `_app`
   |
   = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `app`
  --> src\commands\config.rs:27:5
   |
27 |     app: AppHandle,
   |     ^^^ help: if this is intentional, prefix it with an underscore: `_app`

warning: unused variable: `app`
  --> src\commands\config.rs:47:27
   |
47 | pub async fn reset_config(app: AppHandle, state: State<'_, AppState>) -> Result<AppConfig, String> {
   |                           ^^^ help: if this is intentional, prefix it with an underscore: `_app`

warning: unused variable: `app`
  --> src\commands\config.rs:65:5
   |
65 |     app: AppHandle,
   |     ^^^ help: if this is intentional, prefix it with an underscore: `_app`

warning: unused variable: `app`
  --> src\commands\config.rs:86:5
   |
86 |     app: AppHandle,
   |     ^^^ help: if this is intentional, prefix it with an underscore: `_app`

warning: unused variable: `app`
  --> src\commands\import.rs:78:5
   |
78 |     app: AppHandle,
   |     ^^^ help: if this is intentional, prefix it with an underscore: `_app`

warning: unused variable: `state`
  --> src\commands\import.rs:79:5
   |
79 |     state: State<'_, AppState>,
   |     ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `encoding`
   --> src\commands\import.rs:277:5
    |
277 |     encoding: Option<String>,
    |     ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_encoding`

warning: unused variable: `app`
  --> src\commands\system.rs:20:5
   |
20 |     app: AppHandle,
   |     ^^^ help: if this is intentional, prefix it with an underscore: `_app`

warning: unused variable: `state`
  --> src\commands\system.rs:21:5
   |
21 |     state: State<'_, AppState>,
   |     ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `app`
  --> src\commands\system.rs:37:5
   |
37 |     app: AppHandle,
   |     ^^^ help: if this is intentional, prefix it with an underscore: `_app`

warning: unused variable: `state`
  --> src\commands\system.rs:38:5
   |
38 |     state: State<'_, AppState>,
   |     ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `app`
  --> src\commands\system.rs:49:34
   |
49 | pub async fn stop_system_monitor(app: AppHandle, state: State<'_, AppState>) -> Result<(), String> {
   |                                  ^^^ help: if this is intentional, prefix it with an underscore: `_app`

warning: unused variable: `state`
  --> src\commands\system.rs:49:50
   |
49 | pub async fn stop_system_monitor(app: AppHandle, state: State<'_, AppState>) -> Result<(), String> {
   |                                                  ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `app`
  --> src\commands\system.rs:59:5
   |
59 |     app: AppHandle,
   |     ^^^ help: if this is intentional, prefix it with an underscore: `_app`

warning: unused variable: `app`
  --> src\commands\system.rs:82:5
   |
82 |     app: AppHandle,
   |     ^^^ help: if this is intentional, prefix it with an underscore: `_app`

warning: unused variable: `state`
  --> src\commands\system.rs:83:5
   |
83 |     state: State<'_, AppState>,
   |     ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: variable does not need to be mutable
   --> src\commands\system.rs:545:9
    |
545 |     let mut log_root = if let Some(mut dir) = app.path_resolver().app_config_dir() {
    |         ----^^^^^^^^
    |         |
    |         help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` on by default

warning: unused variable: `app`
  --> src\commands\youtube.rs:17:5
   |
17 |     app: AppHandle,
   |     ^^^ help: if this is intentional, prefix it with an underscore: `_app`

warning: unused variable: `state`
  --> src\commands\youtube.rs:18:5
   |
18 |     state: State<'_, AppState>,
   |     ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `app`
  --> src\commands\youtube.rs:41:5
   |
41 |     app: AppHandle,
   |     ^^^ help: if this is intentional, prefix it with an underscore: `_app`

warning: unused variable: `state`
  --> src\commands\youtube.rs:42:5
   |
42 |     state: State<'_, AppState>,
   |     ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `app`
  --> src\commands\youtube.rs:62:5
   |
62 |     app: AppHandle,
   |     ^^^ help: if this is intentional, prefix it with an underscore: `_app`

warning: unused variable: `state`
  --> src\commands\youtube.rs:63:5
   |
63 |     state: State<'_, AppState>,
   |     ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `url`
   --> src\commands\youtube.rs:227:34
    |
227 | async fn get_video_info_fallback(url: &str, video_id: &str) -> AppResult<YoutubeVideoInfo> {
    |                                  ^^^ help: if this is intentional, prefix it with an underscore: `_url`

warning: unused variable: `playlist_url`
   --> src\commands\youtube.rs:245:5
    |
245 |     playlist_url: &str,
    |     ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_playlist_url`

warning: unused variable: `playlist_id`
   --> src\commands\youtube.rs:246:5
    |
246 |     playlist_id: &str,
    |     ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_playlist_id`

warning: unused variable: `max_videos`
   --> src\commands\youtube.rs:247:5
    |
247 |     max_videos: Option<usize>,
    |     ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_max_videos`

error[E0502]: cannot borrow `*task` as mutable because it is also borrowed as immutable
   --> src\core\downloader.rs:434:21
    |
418 |             &task.id,
    |             -------- immutable borrow occurs here
...
434 |                     self.update_progress(task, downloaded, total, start_time).await;
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here
...
453 |     }
    |     - immutable borrow might be used here, when `resume_future` is dropped and runs the destructor for type `Pin<Box<impl futures_util::Future<Output = Result<resume_downloader::ResumeInfo, anyhow::Error>>>>`

error[E0502]: cannot borrow `*task` as mutable because it is also borrowed as immutable
   --> src\core\downloader.rs:444:21
    |
418 |             &task.id,
    |             -------- immutable borrow occurs here
...
444 |                     self.update_progress(task, downloaded, final_total, start_time).await;
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here
...
453 |     }
    |     - immutable borrow might be used here, when `resume_future` is dropped and runs the destructor for type `Pin<Box<impl futures_util::Future<Output = Result<resume_downloader::ResumeInfo, anyhow::Error>>>>`

warning: variable does not need to be mutable
   --> src\core\downloader.rs:700:21
    |
700 |                 let mut result = downloader.download(task).await?;
    |                     ----^^^^^^
    |                     |
    |                     help: remove this `mut`

warning: unused variable: `downloader_clone`
   --> src\core\manager.rs:989:25
    |
989 |                     let downloader_clone = Arc::clone(&downloader);
    |                         ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_downloader_clone`

warning: unused variable: `event_sender_clone`
   --> src\core\manager.rs:990:25
    |
990 |                     let event_sender_clone = event_sender.clone();
    |                         ^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_event_sender_clone`

warning: unused variable: `integrity_progress_tx`
    --> src\core\manager.rs:1326:34
     |
1326 | ...                   let (integrity_progress_tx, mut integrity_progress_rx) =
     |                            ^^^^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_integrity_progress_tx`

warning: unused variable: `event_sender_integrity`
    --> src\core\manager.rs:1334:33
     |
1334 | ...                   let event_sender_integrity = event_sender.clone();
     |                           ^^^^^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_event_sender_integrity`

warning: unused variable: `active_downloads`
    --> src\core\manager.rs:1056:13
     |
1056 |         let active_downloads = self.active_downloads.len();
     |             ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_active_downloads`

warning: unused variable: `pending_tasks`
    --> src\core\manager.rs:1095:13
     |
1095 |         let pending_tasks = self.task_queue.lock().await.len();
     |             ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_pending_tasks`

warning: unused variable: `current_speed`
    --> src\core\manager.rs:1096:13
     |
1096 |         let current_speed = current_speeds.iter().sum::<f64>() as u64; // Total current speed
     |             ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_current_speed`

warning: unused variable: `current_stats`
    --> src\core\manager.rs:1734:13
     |
1734 |         let current_stats = self.get_stats().await;
     |             ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_current_stats`

warning: unused variable: `active_downloads`
    --> src\core\manager.rs:1735:13
     |
1735 |         let active_downloads = self.active_downloads.len();
     |             ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_active_downloads`

warning: unused variable: `total_tasks`
    --> src\core\manager.rs:1736:13
     |
1736 |         let total_tasks = self.tasks.len();
     |             ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_total_tasks`

warning: unused variable: `pending_tasks`
    --> src\core\manager.rs:1737:13
     |
1737 |         let pending_tasks = self.task_queue.lock().await.len();
     |             ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_pending_tasks`

warning: unused variable: `enabled`
    --> src\core\manager.rs:1744:48
     |
1744 |     pub async fn set_prometheus_enabled(&self, enabled: bool) -> AppResult<()> {
     |                                                ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_enabled`

warning: unused variable: `enabled`
    --> src\core\manager.rs:1750:57
     |
1750 |     pub async fn set_websocket_dashboard_enabled(&self, enabled: bool) -> AppResult<()> {
     |                                                         ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_enabled`

warning: unused variable: `downloader`
    --> src\core\manager.rs:2057:21
     |
2057 |         if let Some(downloader) = &mut self.youtube_downloader {
     |                     ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_downloader`

warning: value assigned to `active_connections` is never read
   --> src\core\monitoring.rs:712:17
    |
712 |         let mut active_connections = 0;
    |                 ^^^^^^^^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?
    = note: `#[warn(unused_assignments)]` on by default

warning: unused variable: `chunk`
   --> src\core\resume_downloader.rs:634:25
    |
634 |             if let Some(chunk) = resume_info.chunks.first() {
    |                         ^^^^^ help: if this is intentional, prefix it with an underscore: `_chunk`

warning: unused variable: `pattern`
   --> src\core\resume_downloader.rs:816:13
    |
816 |         let pattern = format!("{}.chunk.*", task_id);
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_pattern`

warning: unused variable: `format`
   --> src\core\youtube_downloader.rs:341:9
    |
341 |         format: YoutubeDownloadFormat,
    |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_format`

warning: unused variable: `priority`
   --> src\core\youtube_downloader.rs:342:9
    |
342 |         priority: Option<DownloadPriority>,
    |         ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_priority`

warning: unused variable: `url`
   --> src\core\youtube_downloader.rs:379:17
    |
379 |             let url = url.to_string();
    |                 ^^^ help: if this is intentional, prefix it with an underscore: `_url`

error[E0063]: missing field `source_row` in initializer of `VideoRecord`
   --> src\commands\import.rs:572:28
    |
572 |         let video_record = VideoRecord {
    |                            ^^^^^^^^^^^ missing `source_row`

error[E0308]: mismatched types
   --> src\commands\import.rs:582:38
    |
582 |         assert_eq!(imported_data.id, "123");
    |                                      ^^^^^ expected `Option<String>`, found `&str`
    |
    = note:   expected enum `std::option::Option<std::string::String>`
            found reference `&str`

error[E0308]: mismatched types
   --> src\commands\import.rs:583:40
    |
583 |         assert_eq!(imported_data.name, "Test Column");
    |                                        ^^^^^^^^^^^^^ expected `Option<String>`, found `&str`
    |
    = note:   expected enum `std::option::Option<std::string::String>`
            found reference `&str`

error[E0308]: mismatched types
   --> src\commands\import.rs:584:39
    |
584 |         assert_eq!(imported_data.url, "https://example.com/video.mp4");
    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Option<String>`, found `&str`
    |
    = note:   expected enum `std::option::Option<std::string::String>`
            found reference `&str`

error[E0063]: missing field `source_row` in initializer of `VideoRecord`
   --> src\commands\import.rs:591:28
    |
591 |         let video_record = VideoRecord {
    |                            ^^^^^^^^^^^ missing `source_row`

error[E0308]: mismatched types
   --> src\commands\import.rs:601:38
    |
601 |         assert_eq!(imported_data.id, "123");
    |                                      ^^^^^ expected `Option<String>`, found `&str`
    |
    = note:   expected enum `std::option::Option<std::string::String>`
            found reference `&str`

error[E0308]: mismatched types
   --> src\commands\import.rs:602:40
    |
602 |         assert_eq!(imported_data.name, "Test Column");
    |                                        ^^^^^^^^^^^^^ expected `Option<String>`, found `&str`
    |
    = note:   expected enum `std::option::Option<std::string::String>`
            found reference `&str`

error[E0308]: mismatched types
   --> src\commands\import.rs:603:39
    |
603 |         assert_eq!(imported_data.url, "https://example.com/video.mp4");
    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Option<String>`, found `&str`
    |
    = note:   expected enum `std::option::Option<std::string::String>`
            found reference `&str`

error[E0609]: no field `column_id_aliases` on type `file_parser::FieldMapping`
   --> src\commands\import.rs:622:14
    |
622 |             .column_id_aliases
    |              ^^^^^^^^^^^^^^^^^ unknown field
    |
help: a field with a similar name exists
    |
622 -             .column_id_aliases
622 +             .column_id_names
    |

error[E0609]: no field `column_id_aliases` on type `file_parser::FieldMapping`
   --> src\commands\import.rs:625:14
    |
625 |             .column_id_aliases
    |              ^^^^^^^^^^^^^^^^^ unknown field
    |
help: a field with a similar name exists
    |
625 -             .column_id_aliases
625 +             .column_id_names
    |

error[E0609]: no field `video_url_aliases` on type `file_parser::FieldMapping`
   --> src\commands\import.rs:628:14
    |
628 |             .video_url_aliases
    |              ^^^^^^^^^^^^^^^^^ unknown field
    |
help: a field with a similar name exists
    |
628 -             .video_url_aliases
628 +             .video_url_names
    |

error[E0063]: missing field `bandwidth_controller` in initializer of `downloader::HttpDownloader`
   --> src\core\downloader.rs:739:9
    |
739 |         Self {
    |         ^^^^ missing `bandwidth_controller`

error[E0277]: the trait bound `str: StdError` is not satisfied
   --> src\core\error_handling.rs:858:25
    |
858 |         let _ = breaker.call(async { result1 }).await;
    |                         ^^^^ the trait `StdError` is not implemented for `str`
    |
    = note: required for `&str` to implement `StdError`
note: required by a bound in `error_handling::CircuitBreaker::call`
   --> src\core\error_handling.rs:335:12
    |
332 |     pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    |                  ---- required by a bound in this associated function
...
335 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `CircuitBreaker::call`

error[E0277]: the trait bound `str: StdError` is not satisfied
   --> src\core\error_handling.rs:858:17
    |
858 |         let _ = breaker.call(async { result1 }).await;
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `StdError` is not implemented for `str`
    |
    = note: required for `&str` to implement `StdError`
note: required by a bound in `error_handling::CircuitBreaker::call`
   --> src\core\error_handling.rs:335:12
    |
332 |     pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    |                  ---- required by a bound in this associated function
...
335 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `CircuitBreaker::call`

error[E0277]: the trait bound `str: StdError` is not satisfied
   --> src\core\error_handling.rs:858:49
    |
858 |         let _ = breaker.call(async { result1 }).await;
    |                                                 ^^^^^ the trait `StdError` is not implemented for `str`
    |
    = note: required for `&str` to implement `StdError`
note: required by a bound in `error_handling::CircuitBreaker::call`
   --> src\core\error_handling.rs:335:12
    |
332 |     pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    |                  ---- required by a bound in this associated function
...
335 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `CircuitBreaker::call`

error[E0277]: the trait bound `str: StdError` is not satisfied
   --> src\core\error_handling.rs:861:25
    |
861 |         let _ = breaker.call(async { result2 }).await;
    |                         ^^^^ the trait `StdError` is not implemented for `str`
    |
    = note: required for `&str` to implement `StdError`
note: required by a bound in `error_handling::CircuitBreaker::call`
   --> src\core\error_handling.rs:335:12
    |
332 |     pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    |                  ---- required by a bound in this associated function
...
335 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `CircuitBreaker::call`

error[E0277]: the trait bound `str: StdError` is not satisfied
   --> src\core\error_handling.rs:861:17
    |
861 |         let _ = breaker.call(async { result2 }).await;
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `StdError` is not implemented for `str`
    |
    = note: required for `&str` to implement `StdError`
note: required by a bound in `error_handling::CircuitBreaker::call`
   --> src\core\error_handling.rs:335:12
    |
332 |     pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    |                  ---- required by a bound in this associated function
...
335 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `CircuitBreaker::call`

error[E0277]: the trait bound `str: StdError` is not satisfied
   --> src\core\error_handling.rs:861:49
    |
861 |         let _ = breaker.call(async { result2 }).await;
    |                                                 ^^^^^ the trait `StdError` is not implemented for `str`
    |
    = note: required for `&str` to implement `StdError`
note: required by a bound in `error_handling::CircuitBreaker::call`
   --> src\core\error_handling.rs:335:12
    |
332 |     pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    |                  ---- required by a bound in this associated function
...
335 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `CircuitBreaker::call`

error[E0277]: the trait bound `str: StdError` is not satisfied
   --> src\core\error_handling.rs:871:25
    |
871 |         let _ = breaker.call(async { result3 }).await;
    |                         ^^^^ the trait `StdError` is not implemented for `str`
    |
    = note: required for `&str` to implement `StdError`
note: required by a bound in `error_handling::CircuitBreaker::call`
   --> src\core\error_handling.rs:335:12
    |
332 |     pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    |                  ---- required by a bound in this associated function
...
335 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `CircuitBreaker::call`

error[E0277]: the trait bound `str: StdError` is not satisfied
   --> src\core\error_handling.rs:871:17
    |
871 |         let _ = breaker.call(async { result3 }).await;
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `StdError` is not implemented for `str`
    |
    = note: required for `&str` to implement `StdError`
note: required by a bound in `error_handling::CircuitBreaker::call`
   --> src\core\error_handling.rs:335:12
    |
332 |     pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    |                  ---- required by a bound in this associated function
...
335 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `CircuitBreaker::call`

error[E0277]: the trait bound `str: StdError` is not satisfied
   --> src\core\error_handling.rs:871:49
    |
871 |         let _ = breaker.call(async { result3 }).await;
    |                                                 ^^^^^ the trait `StdError` is not implemented for `str`
    |
    = note: required for `&str` to implement `StdError`
note: required by a bound in `error_handling::CircuitBreaker::call`
   --> src\core\error_handling.rs:335:12
    |
332 |     pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    |                  ---- required by a bound in this associated function
...
335 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `CircuitBreaker::call`

error[E0277]: the trait bound `str: StdError` is not satisfied
   --> src\core\error_handling.rs:876:25
    |
876 |         let _ = breaker.call(async { result4 }).await;
    |                         ^^^^ the trait `StdError` is not implemented for `str`
    |
    = note: required for `&str` to implement `StdError`
note: required by a bound in `error_handling::CircuitBreaker::call`
   --> src\core\error_handling.rs:335:12
    |
332 |     pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    |                  ---- required by a bound in this associated function
...
335 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `CircuitBreaker::call`

error[E0277]: the trait bound `str: StdError` is not satisfied
   --> src\core\error_handling.rs:876:17
    |
876 |         let _ = breaker.call(async { result4 }).await;
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `StdError` is not implemented for `str`
    |
    = note: required for `&str` to implement `StdError`
note: required by a bound in `error_handling::CircuitBreaker::call`
   --> src\core\error_handling.rs:335:12
    |
332 |     pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    |                  ---- required by a bound in this associated function
...
335 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `CircuitBreaker::call`

error[E0277]: the trait bound `str: StdError` is not satisfied
   --> src\core\error_handling.rs:876:49
    |
876 |         let _ = breaker.call(async { result4 }).await;
    |                                                 ^^^^^ the trait `StdError` is not implemented for `str`
    |
    = note: required for `&str` to implement `StdError`
note: required by a bound in `error_handling::CircuitBreaker::call`
   --> src\core\error_handling.rs:335:12
    |
332 |     pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    |                  ---- required by a bound in this associated function
...
335 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `CircuitBreaker::call`

error[E0283]: type annotations needed
   --> src\core\error_handling.rs:892:14
    |
892 |             .execute(|_ctx| {
    |              ^^^^^^^ cannot infer type of the type parameter `E` declared on the method `execute`
    |
    = note: cannot satisfy `_: StdError`
note: required by a bound in `error_handling::RetryExecutor::execute`
   --> src\core\error_handling.rs:553:12
    |
545 |     pub async fn execute<F, T, E>(&self, mut f: F) -> AnyhowResult<T>
    |                  ------- required by a bound in this associated function
...
553 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `RetryExecutor::execute`
help: consider specifying the generic arguments
    |
892 |             .execute::<_, std::string::String, E>(|_ctx| {
    |                     +++++++++++++++++++++++++++++

error[E0283]: type annotations needed for `Result<_, anyhow::Error>`
   --> src\core\error_handling.rs:920:13
    |
920 |         let result = executor
    |             ^^^^^^
921 |             .execute(|_ctx| {
    |              ------- type must be known at this point
    |
    = note: cannot satisfy `_: std::marker::Send`
note: required by a bound in `error_handling::RetryExecutor::execute`
   --> src\core\error_handling.rs:552:12
    |
545 |     pub async fn execute<F, T, E>(&self, mut f: F) -> AnyhowResult<T>
    |                  ------- required by a bound in this associated function
...
552 |         T: Send + 'static,
    |            ^^^^ required by this bound in `RetryExecutor::execute`
help: consider giving `result` an explicit type, where the type for type parameter `T` is specified
    |
920 |         let result: Result<T, _> = executor
    |                   ++++++++++++++

error[E0599]: no method named `is_valid` found for struct `integrity_checker::IntegrityResult` in the current scope
    --> src\core\manager.rs:2136:24
     |
2136 |         assert!(result.is_valid() || result.expected_hash().is_none()); // Should pass if no expected hash
     |                        ^^^^^^^^-- help: remove the arguments
     |                        |
     |                        field, not a method
     |
    ::: src\core\integrity_checker.rs:127:1
     |
127  | pub struct IntegrityResult {
     | -------------------------- method `is_valid` not found for this struct

error[E0599]: no method named `expected_hash` found for struct `integrity_checker::IntegrityResult` in the current scope
    --> src\core\manager.rs:2136:45
     |
2136 |         assert!(result.is_valid() || result.expected_hash().is_none()); // Should pass if no expected hash
     |                                             ^^^^^^^^^^^^^-- help: remove the arguments
     |                                             |
     |                                             field, not a method
     |
    ::: src\core\integrity_checker.rs:127:1
     |
127  | pub struct IntegrityResult {
     | -------------------------- method `expected_hash` not found for this struct

error[E0599]: no method named `is_valid` found for struct `integrity_checker::IntegrityResult` in the current scope
    --> src\core\manager.rs:2177:28
     |
2177 |             assert!(result.is_valid() || result.expected_hash().is_none());
     |                            ^^^^^^^^-- help: remove the arguments
     |                            |
     |                            field, not a method
     |
    ::: src\core\integrity_checker.rs:127:1
     |
127  | pub struct IntegrityResult {
     | -------------------------- method `is_valid` not found for this struct

error[E0599]: no method named `expected_hash` found for struct `integrity_checker::IntegrityResult` in the current scope
    --> src\core\manager.rs:2177:49
     |
2177 |             assert!(result.is_valid() || result.expected_hash().is_none());
     |                                                 ^^^^^^^^^^^^^-- help: remove the arguments
     |                                                 |
     |                                                 field, not a method
     |
    ::: src\core\integrity_checker.rs:127:1
     |
127  | pub struct IntegrityResult {
     | -------------------------- method `expected_hash` not found for this struct

error[E0277]: the trait bound `reqwest::Error: From<&str>` is not satisfied
    --> src\core\manager.rs:2283:64
     |
2283 |         let app_error = AppError::Network("Connection timeout".into());
     |                                                                ^^^^ the trait `From<&str>` is not implemented for `reqwest::Error`
     |
     = note: required for `&str` to implement `Into<reqwest::Error>`

error[E0063]: missing fields `auto_verify_integrity`, `expected_hashes` and `integrity_algorithm` in initializer of `models::DownloadConfig`
  --> src\core\manager_test.rs:14:9
   |
14 |         DownloadConfig {
   |         ^^^^^^^^^^^^^^ missing `auto_verify_integrity`, `expected_hashes` and `integrity_algorithm`

error[E0609]: no field `is_running` on type `Result<manager::DownloadManager, models::AppError>`
  --> src\core\manager_test.rs:30:26
   |
30 |         assert!(!manager.is_running);
   |                          ^^^^^^^^^^ unknown field

error[E0609]: no field `config` on type `Result<manager::DownloadManager, models::AppError>`
  --> src\core\manager_test.rs:31:28
   |
31 |         assert_eq!(manager.config.concurrent_downloads, 2);
   |                            ^^^^^^ unknown field

error[E0609]: no field `tasks` on type `Result<manager::DownloadManager, models::AppError>`
  --> src\core\manager_test.rs:32:28
   |
32 |         assert_eq!(manager.tasks.len(), 0);
   |                            ^^^^^ unknown field

error[E0609]: no field `active_downloads` on type `Result<manager::DownloadManager, models::AppError>`
  --> src\core\manager_test.rs:33:28
   |
33 |         assert_eq!(manager.active_downloads.len(), 0);
   |                            ^^^^^^^^^^^^^^^^ unknown field

error[E0609]: no field `is_running` on type `Result<manager::DownloadManager, models::AppError>`
  --> src\core\manager_test.rs:42:26
   |
42 |         assert!(!manager.is_running);
   |                          ^^^^^^^^^^ unknown field

error[E0599]: no method named `start` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:43:17
    |
43  |         manager.start().await?;
    |                 ^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `start` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:334:5
    |
334 |     pub async fn start(&mut self) -> AppResult<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
43  |         manager.expect("REASON").start().await?;
    |                +++++++++++++++++

error[E0609]: no field `is_running` on type `Result<manager::DownloadManager, models::AppError>`
  --> src\core\manager_test.rs:44:25
   |
44 |         assert!(manager.is_running);
   |                         ^^^^^^^^^^ unknown field

error[E0599]: no method named `start` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:47:17
    |
47  |         manager.start().await?; // 搴旇涓嶄細鍑洪敊
    |                 ^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `start` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:334:5
    |
334 |     pub async fn start(&mut self) -> AppResult<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
47  |         manager.expect("REASON").start().await?; // 搴旇涓嶄細鍑洪敊
    |                +++++++++++++++++

error[E0609]: no field `is_running` on type `Result<manager::DownloadManager, models::AppError>`
  --> src\core\manager_test.rs:48:25
   |
48 |         assert!(manager.is_running);
   |                         ^^^^^^^^^^ unknown field

error[E0599]: no method named `stop` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:51:17
    |
51  |         manager.stop().await?;
    |                 ^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `stop` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:384:5
    |
384 |     pub async fn stop(&mut self) -> AppResult<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
51  |         manager.expect("REASON").stop().await?;
    |                +++++++++++++++++

error[E0609]: no field `is_running` on type `Result<manager::DownloadManager, models::AppError>`
  --> src\core\manager_test.rs:52:26
   |
52 |         assert!(!manager.is_running);
   |                          ^^^^^^^^^^ unknown field

error[E0599]: no method named `start` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:62:17
    |
62  |         manager.start().await?;
    |                 ^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `start` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:334:5
    |
334 |     pub async fn start(&mut self) -> AppResult<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
62  |         manager.expect("REASON").start().await?;
    |                +++++++++++++++++

error[E0599]: no method named `add_task` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:65:14
    |
64  |           let task_id = manager
    |  _______________________-
65  | |             .add_task(
    | |             -^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    | |_____________|
    |
    |
note: the method `add_task` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:422:5
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
64  |         let task_id = manager.expect("REASON")
    |                              +++++++++++++++++

error[E0609]: no field `tasks` on type `Result<manager::DownloadManager, models::AppError>`
  --> src\core\manager_test.rs:72:28
   |
72 |         assert_eq!(manager.tasks.len(), 1);
   |                            ^^^^^ unknown field

error[E0609]: no field `tasks` on type `Result<manager::DownloadManager, models::AppError>`
  --> src\core\manager_test.rs:74:28
   |
74 |         let task = manager.tasks.get(&task_id).unwrap();
   |                            ^^^^^ unknown field

error[E0599]: no method named `start` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:87:17
    |
87  |         manager.start().await?;
    |                 ^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `start` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:334:5
    |
334 |     pub async fn start(&mut self) -> AppResult<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
87  |         manager.expect("REASON").start().await?;
    |                +++++++++++++++++

error[E0599]: no method named `add_task` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:90:14
    |
89  |           let task1_id = manager
    |  ________________________-
90  | |             .add_task(
    | |             -^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    | |_____________|
    |
    |
note: the method `add_task` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:422:5
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
89  |         let task1_id = manager.expect("REASON")
    |                               +++++++++++++++++

error[E0599]: no method named `add_task` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:97:14
    |
96  |           let task2_id = manager
    |  ________________________-
97  | |             .add_task(
    | |             -^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    | |_____________|
    |
    |
note: the method `add_task` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:422:5
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
96  |         let task2_id = manager.expect("REASON")
    |                               +++++++++++++++++

error[E0609]: no field `tasks` on type `Result<manager::DownloadManager, models::AppError>`
   --> src\core\manager_test.rs:104:28
    |
104 |         assert_eq!(manager.tasks.len(), 2);
    |                            ^^^^^ unknown field

error[E0599]: no method named `get_stats` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:106:29
    |
106 |         let stats = manager.get_stats().await;
    |                             ^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `get_stats` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:832:5
    |
832 |     pub async fn get_stats(&self) -> ModelsDownloadStats {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
106 |         let stats = manager.expect("REASON").get_stats().await;
    |                            +++++++++++++++++

error[E0599]: no method named `start` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:118:17
    |
118 |         manager.start().await?;
    |                 ^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `start` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:334:5
    |
334 |     pub async fn start(&mut self) -> AppResult<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
118 |         manager.expect("REASON").start().await?;
    |                +++++++++++++++++

error[E0599]: no method named `add_task` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:121:14
    |
120 |           let task_id = manager
    |  _______________________-
121 | |             .add_task(
    | |             -^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    | |_____________|
    |
    |
note: the method `add_task` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:422:5
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
120 |         let task_id = manager.expect("REASON")
    |                              +++++++++++++++++

error[E0609]: no field `tasks` on type `Result<manager::DownloadManager, models::AppError>`
   --> src\core\manager_test.rs:127:28
    |
127 |         assert_eq!(manager.tasks.len(), 1);
    |                            ^^^^^ unknown field

error[E0599]: no method named `remove_task` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:129:17
    |
129 |         manager.remove_task(&task_id).await?;
    |                 ^^^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `remove_task` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:805:5
    |
805 |     pub async fn remove_task(&mut self, task_id: &str) -> AppResult<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
129 |         manager.expect("REASON").remove_task(&task_id).await?;
    |                +++++++++++++++++

error[E0609]: no field `tasks` on type `Result<manager::DownloadManager, models::AppError>`
   --> src\core\manager_test.rs:130:28
    |
130 |         assert_eq!(manager.tasks.len(), 0);
    |                            ^^^^^ unknown field

error[E0599]: no method named `start` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:140:17
    |
140 |         manager.start().await?;
    |                 ^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `start` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:334:5
    |
334 |     pub async fn start(&mut self) -> AppResult<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
140 |         manager.expect("REASON").start().await?;
    |                +++++++++++++++++

error[E0599]: no method named `add_task` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:143:14
    |
142 |           let task_id = manager
    |  _______________________-
143 | |             .add_task(
    | |             -^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    | |_____________|
    |
    |
note: the method `add_task` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:422:5
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
142 |         let task_id = manager.expect("REASON")
    |                              +++++++++++++++++

error[E0599]: no method named `update_task_status` found for enum `Result` in the current scope
    --> src\core\manager_test.rs:151:14
     |
150  | /         manager
151  | |             .update_task_status(&task_id, TaskStatus::Downloading)
     | |             -^^^^^^^^^^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
     | |_____________|
     |
     |
note: the method `update_task_status` exists on the type `manager::DownloadManager`
    --> src\core\manager.rs:1034:5
     |
1034 |     pub async fn update_task_status(&mut self, task_id: &str, status: TaskStatus) -> AppResult<()> {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
     |
150  |         manager.expect("REASON")
     |                +++++++++++++++++

error[E0599]: no method named `remove_task` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:155:30
    |
155 |         let result = manager.remove_task(&task_id).await;
    |                              ^^^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `remove_task` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:805:5
    |
805 |     pub async fn remove_task(&mut self, task_id: &str) -> AppResult<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
155 |         let result = manager.expect("REASON").remove_task(&task_id).await;
    |                             +++++++++++++++++

error[E0599]: no method named `start` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:166:17
    |
166 |         manager.start().await?;
    |                 ^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `start` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:334:5
    |
334 |     pub async fn start(&mut self) -> AppResult<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
166 |         manager.expect("REASON").start().await?;
    |                +++++++++++++++++

error[E0599]: no method named `add_task` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:169:14
    |
168 |           let task_id = manager
    |  _______________________-
169 | |             .add_task(
    | |             -^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    | |_____________|
    |
    |
note: the method `add_task` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:422:5
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
168 |         let task_id = manager.expect("REASON")
    |                              +++++++++++++++++

error[E0599]: no method named `start_download` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:176:30
    |
176 |         let result = manager.start_download(&task_id).await;
    |                              ^^^^^^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `start_download` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:573:5
    |
573 |     pub async fn start_download(&mut self, task_id: &str) -> AppResult<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
176 |         let result = manager.expect("REASON").start_download(&task_id).await;
    |                             +++++++++++++++++

error[E0609]: no field `tasks` on type `Result<manager::DownloadManager, models::AppError>`
   --> src\core\manager_test.rs:182:36
    |
182 |                 let task = manager.tasks.get(&task_id).unwrap();
    |                                    ^^^^^ unknown field

error[E0599]: no method named `start` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:199:17
    |
199 |         manager.start().await?;
    |                 ^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `start` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:334:5
    |
334 |     pub async fn start(&mut self) -> AppResult<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
199 |         manager.expect("REASON").start().await?;
    |                +++++++++++++++++

error[E0599]: no method named `pause_download` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:201:30
    |
201 |         let result = manager.pause_download("nonexistent_id").await;
    |                              ^^^^^^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `pause_download` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:651:5
    |
651 |     pub async fn pause_download(&mut self, task_id: &str) -> AppResult<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
201 |         let result = manager.expect("REASON").pause_download("nonexistent_id").await;
    |                             +++++++++++++++++

error[E0599]: no method named `start` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:212:17
    |
212 |         manager.start().await?;
    |                 ^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `start` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:334:5
    |
334 |     pub async fn start(&mut self) -> AppResult<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
212 |         manager.expect("REASON").start().await?;
    |                +++++++++++++++++

error[E0599]: no method named `add_task` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:215:14
    |
214 |           let task_id = manager
    |  _______________________-
215 | |             .add_task(
    | |             -^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    | |_____________|
    |
    |
note: the method `add_task` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:422:5
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
214 |         let task_id = manager.expect("REASON")
    |                              +++++++++++++++++

error[E0599]: no method named `cancel_download` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:222:17
    |
222 |         manager.cancel_download(&task_id).await?;
    |                 ^^^^^^^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `cancel_download` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:702:5
    |
702 |     pub async fn cancel_download(&mut self, task_id: &str) -> AppResult<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
222 |         manager.expect("REASON").cancel_download(&task_id).await?;
    |                +++++++++++++++++

error[E0609]: no field `tasks` on type `Result<manager::DownloadManager, models::AppError>`
   --> src\core\manager_test.rs:224:28
    |
224 |         let task = manager.tasks.get(&task_id).unwrap();
    |                            ^^^^^ unknown field

error[E0599]: no method named `start` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:235:17
    |
235 |         manager.start().await?;
    |                 ^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `start` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:334:5
    |
334 |     pub async fn start(&mut self) -> AppResult<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
235 |         manager.expect("REASON").start().await?;
    |                +++++++++++++++++

error[E0599]: no method named `add_task` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:239:14
    |
238 |           let task1_id = manager
    |  ________________________-
239 | |             .add_task(
    | |             -^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    | |_____________|
    |
    |
note: the method `add_task` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:422:5
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
238 |         let task1_id = manager.expect("REASON")
    |                               +++++++++++++++++

error[E0599]: no method named `add_task` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:246:14
    |
245 |           let task2_id = manager
    |  ________________________-
246 | |             .add_task(
    | |             -^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    | |_____________|
    |
    |
note: the method `add_task` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:422:5
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
245 |         let task2_id = manager.expect("REASON")
    |                               +++++++++++++++++

error[E0599]: no method named `add_task` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:253:14
    |
252 |           let task3_id = manager
    |  ________________________-
253 | |             .add_task(
    | |             -^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    | |_____________|
    |
    |
note: the method `add_task` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:422:5
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
252 |         let task3_id = manager.expect("REASON")
    |                               +++++++++++++++++

error[E0599]: no method named `update_task_status` found for enum `Result` in the current scope
    --> src\core\manager_test.rs:261:14
     |
260  | /         manager
261  | |             .update_task_status(&task1_id, TaskStatus::Completed)
     | |             -^^^^^^^^^^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
     | |_____________|
     |
     |
note: the method `update_task_status` exists on the type `manager::DownloadManager`
    --> src\core\manager.rs:1034:5
     |
1034 |     pub async fn update_task_status(&mut self, task_id: &str, status: TaskStatus) -> AppResult<()> {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
     |
260  |         manager.expect("REASON")
     |                +++++++++++++++++

error[E0599]: no method named `update_task_status` found for enum `Result` in the current scope
    --> src\core\manager_test.rs:264:14
     |
263  | /         manager
264  | |             .update_task_status(&task2_id, TaskStatus::Completed)
     | |             -^^^^^^^^^^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
     | |_____________|
     |
     |
note: the method `update_task_status` exists on the type `manager::DownloadManager`
    --> src\core\manager.rs:1034:5
     |
1034 |     pub async fn update_task_status(&mut self, task_id: &str, status: TaskStatus) -> AppResult<()> {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
     |
263  |         manager.expect("REASON")
     |                +++++++++++++++++

error[E0609]: no field `tasks` on type `Result<manager::DownloadManager, models::AppError>`
   --> src\core\manager_test.rs:268:28
    |
268 |         assert_eq!(manager.tasks.len(), 3);
    |                            ^^^^^ unknown field

error[E0599]: no method named `clear_completed` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:270:37
    |
270 |         let removed_count = manager.clear_completed().await?;
    |                                     ^^^^^^^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `clear_completed` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:856:5
    |
856 |     pub async fn clear_completed(&mut self) -> AppResult<usize> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
270 |         let removed_count = manager.expect("REASON").clear_completed().await?;
    |                                    +++++++++++++++++

error[E0609]: no field `tasks` on type `Result<manager::DownloadManager, models::AppError>`
   --> src\core\manager_test.rs:273:28
    |
273 |         assert_eq!(manager.tasks.len(), 1);
    |                            ^^^^^ unknown field

error[E0609]: no field `tasks` on type `Result<manager::DownloadManager, models::AppError>`
   --> src\core\manager_test.rs:274:25
    |
274 |         assert!(manager.tasks.contains_key(&task3_id));
    |                         ^^^^^ unknown field

error[E0599]: no method named `start` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:284:17
    |
284 |         manager.start().await?;
    |                 ^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `start` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:334:5
    |
334 |     pub async fn start(&mut self) -> AppResult<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
284 |         manager.expect("REASON").start().await?;
    |                +++++++++++++++++

error[E0599]: no method named `add_task` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:288:14
    |
287 |           let task1_id = manager
    |  ________________________-
288 | |             .add_task(
    | |             -^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    | |_____________|
    |
    |
note: the method `add_task` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:422:5
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
287 |         let task1_id = manager.expect("REASON")
    |                               +++++++++++++++++

error[E0599]: no method named `add_task` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:295:14
    |
294 |           let task2_id = manager
    |  ________________________-
295 | |             .add_task(
    | |             -^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    | |_____________|
    |
    |
note: the method `add_task` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:422:5
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
294 |         let task2_id = manager.expect("REASON")
    |                               +++++++++++++++++

error[E0599]: no method named `update_task_status` found for enum `Result` in the current scope
    --> src\core\manager_test.rs:303:14
     |
302  | /         manager
303  | |             .update_task_status(&task1_id, TaskStatus::Failed)
     | |             -^^^^^^^^^^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
     | |_____________|
     |
     |
note: the method `update_task_status` exists on the type `manager::DownloadManager`
    --> src\core\manager.rs:1034:5
     |
1034 |     pub async fn update_task_status(&mut self, task_id: &str, status: TaskStatus) -> AppResult<()> {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
     |
302  |         manager.expect("REASON")
     |                +++++++++++++++++

error[E0599]: no method named `update_task_status` found for enum `Result` in the current scope
    --> src\core\manager_test.rs:306:14
     |
305  | /         manager
306  | |             .update_task_status(&task2_id, TaskStatus::Completed)
     | |             -^^^^^^^^^^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
     | |_____________|
     |
     |
note: the method `update_task_status` exists on the type `manager::DownloadManager`
    --> src\core\manager.rs:1034:5
     |
1034 |     pub async fn update_task_status(&mut self, task_id: &str, status: TaskStatus) -> AppResult<()> {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
     |
305  |         manager.expect("REASON")
     |                +++++++++++++++++

error[E0599]: no method named `retry_failed` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:309:35
    |
309 |         let retry_count = manager.retry_failed().await?;
    |                                   ^^^^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `retry_failed` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:870:5
    |
870 |     pub async fn retry_failed(&mut self) -> AppResult<usize> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
309 |         let retry_count = manager.expect("REASON").retry_failed().await?;
    |                                  +++++++++++++++++

error[E0609]: no field `tasks` on type `Result<manager::DownloadManager, models::AppError>`
   --> src\core\manager_test.rs:314:29
    |
314 |         let task1 = manager.tasks.get(&task1_id).unwrap();
    |                             ^^^^^ unknown field

error[E0609]: no field `tasks` on type `Result<manager::DownloadManager, models::AppError>`
   --> src\core\manager_test.rs:320:29
    |
320 |         let task2 = manager.tasks.get(&task2_id).unwrap();
    |                             ^^^^^ unknown field

error[E0599]: no method named `start` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:331:17
    |
331 |         manager.start().await?;
    |                 ^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `start` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:334:5
    |
334 |     pub async fn start(&mut self) -> AppResult<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
331 |         manager.expect("REASON").start().await?;
    |                +++++++++++++++++

error[E0599]: no method named `update_config` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:337:17
    |
337 |         manager.update_config(new_config.clone()).await?;
    |                 ^^^^^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `update_config` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:837:5
    |
837 |     pub async fn update_config(&mut self, config: DownloadConfig) -> AppResult<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
337 |         manager.expect("REASON").update_config(new_config.clone()).await?;
    |                +++++++++++++++++

error[E0609]: no field `config` on type `Result<manager::DownloadManager, models::AppError>`
   --> src\core\manager_test.rs:339:28
    |
339 |         assert_eq!(manager.config.concurrent_downloads, 5);
    |                            ^^^^^^ unknown field

error[E0609]: no field `config` on type `Result<manager::DownloadManager, models::AppError>`
   --> src\core\manager_test.rs:340:28
    |
340 |         assert_eq!(manager.config.timeout_seconds, 60);
    |                            ^^^^^^ unknown field

error[E0599]: no method named `get_tasks` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:350:29
    |
350 |         let tasks = manager.get_tasks().await;
    |                             ^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `get_tasks` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:827:5
    |
827 |     pub async fn get_tasks(&self) -> Vec<VideoTask> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
350 |         let tasks = manager.expect("REASON").get_tasks().await;
    |                            +++++++++++++++++

error[E0599]: no method named `start` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:361:17
    |
361 |         manager.start().await?;
    |                 ^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `start` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:334:5
    |
334 |     pub async fn start(&mut self) -> AppResult<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
361 |         manager.expect("REASON").start().await?;
    |                +++++++++++++++++

error[E0599]: no method named `add_task` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:365:14
    |
364 |           let task1_id = manager
    |  ________________________-
365 | |             .add_task(
    | |             -^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    | |_____________|
    |
    |
note: the method `add_task` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:422:5
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
364 |         let task1_id = manager.expect("REASON")
    |                               +++++++++++++++++

error[E0599]: no method named `add_task` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:372:14
    |
371 |           let task2_id = manager
    |  ________________________-
372 | |             .add_task(
    | |             -^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    | |_____________|
    |
    |
note: the method `add_task` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:422:5
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
371 |         let task2_id = manager.expect("REASON")
    |                               +++++++++++++++++

error[E0599]: no method named `add_task` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:379:14
    |
378 |           let task3_id = manager
    |  ________________________-
379 | |             .add_task(
    | |             -^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    | |_____________|
    |
    |
note: the method `add_task` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:422:5
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
378 |         let task3_id = manager.expect("REASON")
    |                               +++++++++++++++++

error[E0599]: no method named `update_task_status` found for enum `Result` in the current scope
    --> src\core\manager_test.rs:387:14
     |
386  | /         manager
387  | |             .update_task_status(&task1_id, TaskStatus::Completed)
     | |             -^^^^^^^^^^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
     | |_____________|
     |
     |
note: the method `update_task_status` exists on the type `manager::DownloadManager`
    --> src\core\manager.rs:1034:5
     |
1034 |     pub async fn update_task_status(&mut self, task_id: &str, status: TaskStatus) -> AppResult<()> {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
     |
386  |         manager.expect("REASON")
     |                +++++++++++++++++

error[E0599]: no method named `update_task_status` found for enum `Result` in the current scope
    --> src\core\manager_test.rs:390:14
     |
389  | /         manager
390  | |             .update_task_status(&task2_id, TaskStatus::Failed)
     | |             -^^^^^^^^^^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
     | |_____________|
     |
     |
note: the method `update_task_status` exists on the type `manager::DownloadManager`
    --> src\core\manager.rs:1034:5
     |
1034 |     pub async fn update_task_status(&mut self, task_id: &str, status: TaskStatus) -> AppResult<()> {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
     |
389  |         manager.expect("REASON")
     |                +++++++++++++++++

error[E0599]: no method named `get_stats` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:394:29
    |
394 |         let stats = manager.get_stats().await;
    |                             ^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `get_stats` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:832:5
    |
832 |     pub async fn get_stats(&self) -> ModelsDownloadStats {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
394 |         let stats = manager.expect("REASON").get_stats().await;
    |                            +++++++++++++++++

error[E0599]: no method named `start` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:410:17
    |
410 |         manager.start().await?;
    |                 ^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `start` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:334:5
    |
334 |     pub async fn start(&mut self) -> AppResult<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
410 |         manager.expect("REASON").start().await?;
    |                +++++++++++++++++

error[E0599]: no method named `add_task` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:413:14
    |
412 |           let task1_id = manager
    |  ________________________-
413 | |             .add_task(
    | |             -^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    | |_____________|
    |
    |
note: the method `add_task` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:422:5
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
412 |         let task1_id = manager.expect("REASON")
    |                               +++++++++++++++++

error[E0599]: no method named `add_task` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:420:14
    |
419 |           let task2_id = manager
    |  ________________________-
420 | |             .add_task(
    | |             -^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    | |_____________|
    |
    |
note: the method `add_task` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:422:5
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
419 |         let task2_id = manager.expect("REASON")
    |                               +++++++++++++++++

error[E0599]: no method named `start_download` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:427:37
    |
427 |         let start1_result = manager.start_download(&task1_id).await;
    |                                     ^^^^^^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `start_download` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:573:5
    |
573 |     pub async fn start_download(&mut self, task_id: &str) -> AppResult<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
427 |         let start1_result = manager.expect("REASON").start_download(&task1_id).await;
    |                                    +++++++++++++++++

error[E0599]: no method named `start_download` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:428:37
    |
428 |         let start2_result = manager.start_download(&task2_id).await;
    |                                     ^^^^^^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `start_download` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:573:5
    |
573 |     pub async fn start_download(&mut self, task_id: &str) -> AppResult<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
428 |         let start2_result = manager.expect("REASON").start_download(&task2_id).await;
    |                                    +++++++++++++++++

error[E0599]: no method named `extract_title_from_url` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:444:30
    |
444 |         let title1 = manager.extract_title_from_url("https://example.com/video.mp4");
    |                              ^^^^^^^^^^^^^^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`

error[E0599]: no method named `extract_title_from_url` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:448:30
    |
448 |         let title2 = manager.extract_title_from_url("https://example.com/video.mp4?v=123");
    |                              ^^^^^^^^^^^^^^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`

error[E0599]: no method named `extract_title_from_url` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:452:30
    |
452 |         let title3 = manager.extract_title_from_url("https://example.com/path/to/video.mp4");
    |                              ^^^^^^^^^^^^^^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`

error[E0599]: no method named `extract_title_from_url` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:456:30
    |
456 |         let title4 = manager.extract_title_from_url("https://example.com/");
    |                              ^^^^^^^^^^^^^^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`

error[E0599]: no method named `extract_title_from_url` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:460:30
    |
460 |         let title5 = manager.extract_title_from_url("");
    |                              ^^^^^^^^^^^^^^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`

error[E0599]: no method named `start` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:470:17
    |
470 |         manager.start().await?;
    |                 ^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `start` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:334:5
    |
334 |     pub async fn start(&mut self) -> AppResult<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
470 |         manager.expect("REASON").start().await?;
    |                +++++++++++++++++

error[E0599]: no method named `add_task` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:478:18
    |
477 |               let task_id = manager
    |  ___________________________-
478 | |                 .add_task(
    | |                 -^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    | |_________________|
    |
    |
note: the method `add_task` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:422:5
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
477 |             let task_id = manager.expect("REASON")
    |                                  +++++++++++++++++

error[E0609]: no field `tasks` on type `Result<manager::DownloadManager, models::AppError>`
   --> src\core\manager_test.rs:486:28
    |
486 |         assert_eq!(manager.tasks.len(), task_count);
    |                            ^^^^^ unknown field

error[E0282]: type annotations needed
   --> src\core\manager_test.rs:477:17
    |
477 |             let task_id = manager
    |                 ^^^^^^^
...
492 |             assert!(unique_ids.insert(id.clone()));
    |                                          ----- type must be known at this point
    |
help: consider giving `task_id` an explicit type
    |
477 |             let task_id: /* Type */ = manager
    |                        ++++++++++++

error[E0599]: no method named `get_stats` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:495:29
    |
495 |         let stats = manager.get_stats().await;
    |                             ^^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `get_stats` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:832:5
    |
832 |     pub async fn get_stats(&self) -> ModelsDownloadStats {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
495 |         let stats = manager.expect("REASON").get_stats().await;
    |                            +++++++++++++++++

error[E0599]: no method named `start` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:508:21
    |
508 |             manager.start().await?;
    |                     ^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    |
note: the method `start` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:334:5
    |
334 |     pub async fn start(&mut self) -> AppResult<()> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
508 |             manager.expect("REASON").start().await?;
    |                    +++++++++++++++++

error[E0599]: no method named `add_task` found for enum `Result` in the current scope
   --> src\core\manager_test.rs:511:18
    |
510 |               let _task_id = manager
    |  ____________________________-
511 | |                 .add_task(
    | |                 -^^^^^^^^ method not found in `Result<manager::DownloadManager, models::AppError>`
    | |_________________|
    |
    |
note: the method `add_task` exists on the type `manager::DownloadManager`
   --> src\core\manager.rs:422:5
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `manager::DownloadManager` value, panicking if the value is a `Result::Err`
    |
510 |             let _task_id = manager.expect("REASON")
    |                                   +++++++++++++++++

error[E0063]: missing fields `auto_verify_integrity`, `expected_hashes` and `integrity_algorithm` in initializer of `models::DownloadConfig`
  --> src\core\integration_tests.rs:20:9
   |
20 |         DownloadConfig {
   |         ^^^^^^^^^^^^^^ missing `auto_verify_integrity`, `expected_hashes` and `integrity_algorithm`

error[E0063]: missing field `video_info` in initializer of `models::VideoTask`
  --> src\core\integration_tests.rs:33:9
   |
33 |         VideoTask {
   |         ^^^^^^^^^ missing `video_info`

error[E0599]: no method named `get_current_stats` found for struct `manager::DownloadManager` in the current scope
   --> src\core\integration_tests.rs:62:29
    |
62  |         let stats = manager.get_current_stats().await;
    |                             ^^^^^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_current_stats` not found for this struct
    |
help: there is a method `get_stats` with a similar name
    |
62  -         let stats = manager.get_current_stats().await;
62  +         let stats = manager.get_stats().await;
    |

error[E0061]: this method takes 2 arguments but 1 argument was supplied
   --> src\core\integration_tests.rs:82:31
    |
82  |         let result1 = manager.add_task(task1).await;
    |                               ^^^^^^^^-------
    |                                       ||
    |                                       |expected `String`, found `VideoTask`
    |                                       argument #2 of type `std::string::String` is missing
    |
note: method defined here
   --> src\core\manager.rs:422:18
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |                  ^^^^^^^^            -----------  -------------------
help: provide the argument
    |
82  -         let result1 = manager.add_task(task1).await;
82  +         let result1 = manager.add_task(/* std::string::String */, /* std::string::String */).await;
    |

error[E0061]: this method takes 2 arguments but 1 argument was supplied
   --> src\core\integration_tests.rs:83:31
    |
83  |         let result2 = manager.add_task(task2).await;
    |                               ^^^^^^^^-------
    |                                       ||
    |                                       |expected `String`, found `VideoTask`
    |                                       argument #2 of type `std::string::String` is missing
    |
note: method defined here
   --> src\core\manager.rs:422:18
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |                  ^^^^^^^^            -----------  -------------------
help: provide the argument
    |
83  -         let result2 = manager.add_task(task2).await;
83  +         let result2 = manager.add_task(/* std::string::String */, /* std::string::String */).await;
    |

error[E0599]: no method named `get_current_stats` found for struct `manager::DownloadManager` in the current scope
   --> src\core\integration_tests.rs:89:29
    |
89  |         let stats = manager.get_current_stats().await;
    |                             ^^^^^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_current_stats` not found for this struct
    |
help: there is a method `get_stats` with a similar name
    |
89  -         let stats = manager.get_current_stats().await;
89  +         let stats = manager.get_stats().await;
    |

error[E0599]: no method named `get_all_tasks` found for struct `manager::DownloadManager` in the current scope
   --> src\core\integration_tests.rs:93:29
    |
93  |         let tasks = manager.get_all_tasks().await;
    |                             ^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_all_tasks` not found for this struct
    |
help: there is a method `get_tasks` with a similar name
    |
93  -         let tasks = manager.get_all_tasks().await;
93  +         let tasks = manager.get_tasks().await;
    |

error[E0599]: no method named `update_task_progress` found for struct `manager::DownloadManager` in the current scope
   --> src\core\integration_tests.rs:104:14
    |
103 |           let update_result = manager
    |  _____________________________-
104 | |             .update_task_progress(
    | |_____________-^^^^^^^^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 |   pub struct DownloadManager {
    |   -------------------------- method `update_task_progress` not found for this struct
    |
help: there is a method `update_task_status` with a similar name
    |
104 -             .update_task_progress(
104 +             .update_task_status(
    |

error[E0599]: no method named `get_all_tasks` found for struct `manager::DownloadManager` in the current scope
   --> src\core\integration_tests.rs:119:29
    |
119 |         let tasks = manager.get_all_tasks().await;
    |                             ^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_all_tasks` not found for this struct
    |
help: there is a method `get_tasks` with a similar name
    |
119 -         let tasks = manager.get_all_tasks().await;
119 +         let tasks = manager.get_tasks().await;
    |

error[E0599]: no method named `get_current_stats` found for struct `manager::DownloadManager` in the current scope
   --> src\core\integration_tests.rs:129:42
    |
129 |         let stats_after_remove = manager.get_current_stats().await;
    |                                          ^^^^^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_current_stats` not found for this struct
    |
help: there is a method `get_stats` with a similar name
    |
129 -         let stats_after_remove = manager.get_current_stats().await;
129 +         let stats_after_remove = manager.get_stats().await;
    |

error[E0599]: no method named `get_all_tasks` found for struct `manager::DownloadManager` in the current scope
   --> src\core\integration_tests.rs:133:42
    |
133 |         let tasks_after_remove = manager.get_all_tasks().await;
    |                                          ^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_all_tasks` not found for this struct
    |
help: there is a method `get_tasks` with a similar name
    |
133 -         let tasks_after_remove = manager.get_all_tasks().await;
133 +         let tasks_after_remove = manager.get_tasks().await;
    |

error[E0061]: this method takes 2 arguments but 1 argument was supplied
   --> src\core\integration_tests.rs:155:34
    |
155 |             let result = manager.add_task(task).await;
    |                                  ^^^^^^^^------
    |                                          ||
    |                                          |expected `String`, found `VideoTask`
    |                                          argument #2 of type `std::string::String` is missing
    |
note: method defined here
   --> src\core\manager.rs:422:18
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |                  ^^^^^^^^            -----------  -------------------
help: provide the argument
    |
155 -             let result = manager.add_task(task).await;
155 +             let result = manager.add_task(/* std::string::String */, /* std::string::String */).await;
    |

error[E0599]: no method named `get_current_stats` found for struct `manager::DownloadManager` in the current scope
   --> src\core\integration_tests.rs:160:29
    |
160 |         let stats = manager.get_current_stats().await;
    |                             ^^^^^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_current_stats` not found for this struct
    |
help: there is a method `get_stats` with a similar name
    |
160 -         let stats = manager.get_current_stats().await;
160 +         let stats = manager.get_stats().await;
    |

error[E0599]: no method named `get_all_tasks` found for struct `manager::DownloadManager` in the current scope
   --> src\core\integration_tests.rs:170:29
    |
170 |         let tasks = manager.get_all_tasks().await;
    |                             ^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_all_tasks` not found for this struct
    |
help: there is a method `get_tasks` with a similar name
    |
170 -         let tasks = manager.get_all_tasks().await;
170 +         let tasks = manager.get_tasks().await;
    |

error[E0061]: this method takes 2 arguments but 1 argument was supplied
   --> src\core\integration_tests.rs:190:30
    |
190 |         let result = manager.add_task(task).await;
    |                              ^^^^^^^^------
    |                                      ||
    |                                      |expected `String`, found `VideoTask`
    |                                      argument #2 of type `std::string::String` is missing
    |
note: method defined here
   --> src\core\manager.rs:422:18
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |                  ^^^^^^^^            -----------  -------------------
help: provide the argument
    |
190 -         let result = manager.add_task(task).await;
190 +         let result = manager.add_task(/* std::string::String */, /* std::string::String */).await;
    |

error[E0599]: no method named `get_all_tasks` found for struct `manager::DownloadManager` in the current scope
   --> src\core\integration_tests.rs:194:29
    |
194 |         let tasks = manager.get_all_tasks().await;
    |                             ^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_all_tasks` not found for this struct
    |
help: there is a method `get_tasks` with a similar name
    |
194 -         let tasks = manager.get_all_tasks().await;
194 +         let tasks = manager.get_tasks().await;
    |

error[E0599]: no method named `get_current_stats` found for struct `manager::DownloadManager` in the current scope
   --> src\core\integration_tests.rs:200:29
    |
200 |         let stats = manager.get_current_stats().await;
    |                             ^^^^^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_current_stats` not found for this struct
    |
help: there is a method `get_stats` with a similar name
    |
200 -         let stats = manager.get_current_stats().await;
200 +         let stats = manager.get_stats().await;
    |

error[E0599]: no method named `reset_task` found for struct `manager::DownloadManager` in the current scope
   --> src\core\integration_tests.rs:204:36
    |
204 |         let reset_result = manager.reset_task(&task_id).await;
    |                                    ^^^^^^^^^^ method not found in `manager::DownloadManager`
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `reset_task` not found for this struct

error[E0599]: no method named `get_all_tasks` found for struct `manager::DownloadManager` in the current scope
   --> src\core\integration_tests.rs:207:41
    |
207 |         let tasks_after_reset = manager.get_all_tasks().await;
    |                                         ^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_all_tasks` not found for this struct
    |
help: there is a method `get_tasks` with a similar name
    |
207 -         let tasks_after_reset = manager.get_all_tasks().await;
207 +         let tasks_after_reset = manager.get_tasks().await;
    |

error[E0061]: this method takes 2 arguments but 1 argument was supplied
   --> src\core\integration_tests.rs:246:34
    |
246 |             let result = manager.add_task(task).await;
    |                                  ^^^^^^^^------
    |                                          ||
    |                                          |expected `String`, found `VideoTask`
    |                                          argument #2 of type `std::string::String` is missing
    |
note: method defined here
   --> src\core\manager.rs:422:18
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |                  ^^^^^^^^            -----------  -------------------
help: provide the argument
    |
246 -             let result = manager.add_task(task).await;
246 +             let result = manager.add_task(/* std::string::String */, /* std::string::String */).await;
    |

error[E0599]: no method named `get_current_stats` found for struct `manager::DownloadManager` in the current scope
   --> src\core\integration_tests.rs:251:29
    |
251 |         let stats = manager.get_current_stats().await;
    |                             ^^^^^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_current_stats` not found for this struct
    |
help: there is a method `get_stats` with a similar name
    |
251 -         let stats = manager.get_current_stats().await;
251 +         let stats = manager.get_stats().await;
    |

error[E0061]: this method takes 2 arguments but 1 argument was supplied
   --> src\core\integration_tests.rs:289:34
    |
289 |             let result = manager.add_task(task).await;
    |                                  ^^^^^^^^------
    |                                          ||
    |                                          |expected `String`, found `VideoTask`
    |                                          argument #2 of type `std::string::String` is missing
    |
note: method defined here
   --> src\core\manager.rs:422:18
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |                  ^^^^^^^^            -----------  -------------------
help: provide the argument
    |
289 -             let result = manager.add_task(task).await;
289 +             let result = manager.add_task(/* std::string::String */, /* std::string::String */).await;
    |

error[E0599]: no method named `get_all_tasks` found for struct `manager::DownloadManager` in the current scope
   --> src\core\integration_tests.rs:294:33
    |
294 |         let all_tasks = manager.get_all_tasks().await;
    |                                 ^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_all_tasks` not found for this struct
    |
help: there is a method `get_tasks` with a similar name
    |
294 -         let all_tasks = manager.get_all_tasks().await;
294 +         let all_tasks = manager.get_tasks().await;
    |

error[E0599]: no method named `get_tasks_by_status` found for struct `manager::DownloadManager` in the current scope
    --> src\core\integration_tests.rs:298:39
     |
298  |         let completed_tasks = manager.get_tasks_by_status(TaskStatus::Completed).await;
     |                                       ^^^^^^^^^^^^^^^^^^^
     |
    ::: src\core\manager.rs:197:1
     |
197  | pub struct DownloadManager {
     | -------------------------- method `get_tasks_by_status` not found for this struct
     |
help: there is a method `get_retry_stats` with a similar name, but with different arguments
    --> src\core\manager.rs:1569:5
     |
1569 |     pub async fn get_retry_stats(&self) -> RetryStats {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `get_tasks_by_status` found for struct `manager::DownloadManager` in the current scope
    --> src\core\integration_tests.rs:302:37
     |
302  |         let pending_tasks = manager.get_tasks_by_status(TaskStatus::Pending).await;
     |                                     ^^^^^^^^^^^^^^^^^^^
     |
    ::: src\core\manager.rs:197:1
     |
197  | pub struct DownloadManager {
     | -------------------------- method `get_tasks_by_status` not found for this struct
     |
help: there is a method `get_retry_stats` with a similar name, but with different arguments
    --> src\core\manager.rs:1569:5
     |
1569 |     pub async fn get_retry_stats(&self) -> RetryStats {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `get_tasks_by_status` found for struct `manager::DownloadManager` in the current scope
    --> src\core\integration_tests.rs:306:41
     |
306  |         let downloading_tasks = manager.get_tasks_by_status(TaskStatus::Downloading).await;
     |                                         ^^^^^^^^^^^^^^^^^^^
     |
    ::: src\core\manager.rs:197:1
     |
197  | pub struct DownloadManager {
     | -------------------------- method `get_tasks_by_status` not found for this struct
     |
help: there is a method `get_retry_stats` with a similar name, but with different arguments
    --> src\core\manager.rs:1569:5
     |
1569 |     pub async fn get_retry_stats(&self) -> RetryStats {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0061]: this method takes 2 arguments but 1 argument was supplied
   --> src\core\integration_tests.rs:324:34
    |
324 |             let result = manager.add_task(task).await;
    |                                  ^^^^^^^^------
    |                                          ||
    |                                          |expected `String`, found `VideoTask`
    |                                          argument #2 of type `std::string::String` is missing
    |
note: method defined here
   --> src\core\manager.rs:422:18
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |                  ^^^^^^^^            -----------  -------------------
help: provide the argument
    |
324 -             let result = manager.add_task(task).await;
324 +             let result = manager.add_task(/* std::string::String */, /* std::string::String */).await;
    |

error[E0599]: no method named `get_current_stats` found for struct `manager::DownloadManager` in the current scope
   --> src\core\integration_tests.rs:329:28
    |
329 |         assert_eq!(manager.get_current_stats().await.total_tasks, 5);
    |                            ^^^^^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_current_stats` not found for this struct
    |
help: there is a method `get_stats` with a similar name
    |
329 -         assert_eq!(manager.get_current_stats().await.total_tasks, 5);
329 +         assert_eq!(manager.get_stats().await.total_tasks, 5);
    |

error[E0599]: no method named `get_all_tasks` found for struct `manager::DownloadManager` in the current scope
   --> src\core\integration_tests.rs:342:29
    |
342 |         let tasks = manager.get_all_tasks().await;
    |                             ^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_all_tasks` not found for this struct
    |
help: there is a method `get_tasks` with a similar name
    |
342 -         let tasks = manager.get_all_tasks().await;
342 +         let tasks = manager.get_tasks().await;
    |

error[E0599]: no method named `get_current_stats` found for struct `manager::DownloadManager` in the current scope
   --> src\core\integration_tests.rs:365:35
    |
365 |         let final_stats = manager.get_current_stats().await;
    |                                   ^^^^^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_current_stats` not found for this struct
    |
help: there is a method `get_stats` with a similar name
    |
365 -         let final_stats = manager.get_current_stats().await;
365 +         let final_stats = manager.get_stats().await;
    |

error[E0599]: no method named `get_all_tasks` found for struct `manager::DownloadManager` in the current scope
   --> src\core\integration_tests.rs:368:35
    |
368 |         let final_tasks = manager.get_all_tasks().await;
    |                                   ^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_all_tasks` not found for this struct
    |
help: there is a method `get_tasks` with a similar name
    |
368 -         let final_tasks = manager.get_all_tasks().await;
368 +         let final_tasks = manager.get_tasks().await;
    |

error[E0599]: no method named `get_config` found for struct `manager::DownloadManager` in the current scope
   --> src\core\integration_tests.rs:383:38
    |
383 |         let current_config = manager.get_config().await;
    |                                      ^^^^^^^^^^ method not found in `manager::DownloadManager`
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_config` not found for this struct

error[E0599]: no method named `get_config` found for struct `manager::DownloadManager` in the current scope
   --> src\core\integration_tests.rs:402:38
    |
402 |         let updated_config = manager.get_config().await;
    |                                      ^^^^^^^^^^ method not found in `manager::DownloadManager`
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_config` not found for this struct

error[E0061]: this method takes 2 arguments but 1 argument was supplied
   --> src\core\integration_tests.rs:424:30
    |
424 |         let result = manager.add_task(task).await;
    |                              ^^^^^^^^------
    |                                      ||
    |                                      |expected `String`, found `VideoTask`
    |                                      argument #2 of type `std::string::String` is missing
    |
note: method defined here
   --> src\core\manager.rs:422:18
    |
422 |     pub async fn add_task(&mut self, url: String, output_path: String) -> AppResult<String> {
    |                  ^^^^^^^^            -----------  -------------------
help: provide the argument
    |
424 -         let result = manager.add_task(task).await;
424 +         let result = manager.add_task(/* std::string::String */, /* std::string::String */).await;
    |

error[E0599]: no method named `update_task_progress` found for struct `manager::DownloadManager` in the current scope
   --> src\core\integration_tests.rs:450:18
    |
449 |               let result = manager
    |  __________________________-
450 | |                 .update_task_progress(&task_id, progress_update)
    | |_________________-^^^^^^^^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 |   pub struct DownloadManager {
    |   -------------------------- method `update_task_progress` not found for this struct
    |
help: there is a method `update_task_status` with a similar name
    |
450 -                 .update_task_progress(&task_id, progress_update)
450 +                 .update_task_status(&task_id, progress_update)
    |

error[E0599]: no method named `get_all_tasks` found for struct `manager::DownloadManager` in the current scope
   --> src\core\integration_tests.rs:455:33
    |
455 |             let tasks = manager.get_all_tasks().await;
    |                                 ^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_all_tasks` not found for this struct
    |
help: there is a method `get_tasks` with a similar name
    |
455 -             let tasks = manager.get_all_tasks().await;
455 +             let tasks = manager.get_tasks().await;
    |

error[E0599]: no method named `get_current_stats` found for struct `manager::DownloadManager` in the current scope
   --> src\core\integration_tests.rs:471:35
    |
471 |         let final_stats = manager.get_current_stats().await;
    |                                   ^^^^^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_current_stats` not found for this struct
    |
help: there is a method `get_stats` with a similar name
    |
471 -         let final_stats = manager.get_current_stats().await;
471 +         let final_stats = manager.get_stats().await;
    |

error[E0308]: mismatched types
   --> src\core\resume_downloader_integration_tests.rs:50:55
    |
50  |             .download_with_resume(&task_id, test_url, &output_path, None, None)
    |              --------------------                     ^^^^^^^^^^^^ expected `&Path`, found `&String`
    |              |
    |              arguments to this method are incorrect
    |
    = note: expected reference `&std::path::Path`
               found reference `&std::string::String`
note: method defined here
   --> src\core\resume_downloader.rs:312:18
    |
312 |     pub async fn download_with_resume(
    |                  ^^^^^^^^^^^^^^^^^^^^
...
316 |         file_path: &Path,
    |         ----------------

error[E0308]: mismatched types
  --> src\core\resume_downloader_integration_tests.rs:54:16
   |
53 |         match result {
   |               ------ this expression has type `Result<resume_downloader::ResumeInfo, anyhow::Error>`
54 |             Ok(()) => {
   |                ^^ expected `ResumeInfo`, found `()`

error[E0624]: method `save_resume_info` is private
   --> src\core\resume_downloader_integration_tests.rs:118:38
    |
118 |         let save_result = downloader.save_resume_info(&resume_info).await;
    |                                      ^^^^^^^^^^^^^^^^ private method
    |
   ::: src\core\resume_downloader.rs:749:5
    |
749 |     async fn save_resume_info(&self, resume_info: &ResumeInfo) -> Result<()> {
    |     ------------------------------------------------------------------------ private method defined here

error[E0624]: method `load_resume_info` is private
   --> src\core\resume_downloader_integration_tests.rs:122:38
    |
122 |         let load_result = downloader.load_resume_info(&task_id).await;
    |                                      ^^^^^^^^^^^^^^^^ private method
    |
   ::: src\core\resume_downloader.rs:716:5
    |
716 |     async fn load_resume_info(&self, task_id: &str) -> Result<Option<ResumeInfo>> {
    |     ----------------------------------------------------------------------------- private method defined here

error[E0624]: method `create_chunks` is private
   --> src\core\resume_downloader_integration_tests.rs:157:37
    |
157 |             let chunks = downloader.create_chunks(&resume_info).await.unwrap();
    |                                     ^^^^^^^^^^^^^ private method
    |
   ::: src\core\resume_downloader.rs:375:5
    |
375 |     async fn create_chunks(&self, resume_info: &ResumeInfo) -> Result<Vec<ChunkInfo>> {
    |     --------------------------------------------------------------------------------- private method defined here

error[E0624]: method `save_resume_info` is private
   --> src\core\resume_downloader_integration_tests.rs:208:20
    |
208 |         downloader.save_resume_info(&resume_info).await.unwrap();
    |                    ^^^^^^^^^^^^^^^^ private method
    |
   ::: src\core\resume_downloader.rs:749:5
    |
749 |     async fn save_resume_info(&self, resume_info: &ResumeInfo) -> Result<()> {
    |     ------------------------------------------------------------------------ private method defined here

error[E0308]: mismatched types
   --> src\core\resume_downloader_integration_tests.rs:305:17
    |
302 |             .download_with_resume(
    |              -------------------- arguments to this method are incorrect
...
305 |                 invalid_path,
    |                 ^^^^^^^^^^^^ expected `&Path`, found `&str`
    |
    = note: expected reference `&std::path::Path`
               found reference `&str`
note: method defined here
   --> src\core\resume_downloader.rs:312:18
    |
312 |     pub async fn download_with_resume(
    |                  ^^^^^^^^^^^^^^^^^^^^
...
316 |         file_path: &Path,
    |         ----------------

error[E0624]: method `load_resume_info` is private
   --> src\core\resume_downloader_integration_tests.rs:320:33
    |
320 |         let result = downloader.load_resume_info(&nonexistent_task).await;
    |                                 ^^^^^^^^^^^^^^^^ private method
    |
   ::: src\core\resume_downloader.rs:716:5
    |
716 |     async fn load_resume_info(&self, task_id: &str) -> Result<Option<ResumeInfo>> {
    |     ----------------------------------------------------------------------------- private method defined here

error[E0624]: method `is_m3u8_url` is private
   --> src\core\m3u8_integration_tests.rs:50:32
    |
50  |             assert!(downloader.is_m3u8_url(url), "搴旇璇嗗埆涓篗3U8 URL: {}", url);
    |                                ^^^^^^^^^^^ private method
    |
   ::: src\core\downloader.rs:493:5
    |
493 |     fn is_m3u8_url(&self, url: &str) -> bool {
    |     ---------------------------------------- private method defined here

error[E0624]: method `is_m3u8_url` is private
   --> src\core\m3u8_integration_tests.rs:55:29
    |
55  |                 !downloader.is_m3u8_url(url),
    |                             ^^^^^^^^^^^ private method
    |
   ::: src\core\downloader.rs:493:5
    |
493 |     fn is_m3u8_url(&self, url: &str) -> bool {
    |     ---------------------------------------- private method defined here

error[E0624]: method `is_m3u8_url` is private
   --> src\core\m3u8_integration_tests.rs:78:28
    |
78  |         assert!(downloader.is_m3u8_url(&task.url));
    |                            ^^^^^^^^^^^ private method
    |
   ::: src\core\downloader.rs:493:5
    |
493 |     fn is_m3u8_url(&self, url: &str) -> bool {
    |     ---------------------------------------- private method defined here

error[E0624]: method `parse_m3u8_content` is private
   --> src\core\m3u8_integration_tests.rs:107:14
    |
107 |             .parse_m3u8_content("https://example.com/playlist.m3u8", m3u8_content)
    |              ^^^^^^^^^^^^^^^^^^ private method
    |
   ::: src\core\m3u8_downloader.rs:265:5
    |
265 |     async fn parse_m3u8_content(&self, m3u8_url: &str, content: &str) -> Result<M3U8Playlist> {
    |     ----------------------------------------------------------------------------------------- private method defined here

error[E0624]: method `is_m3u8_url` is private
   --> src\core\m3u8_integration_tests.rs:142:38
    |
142 |             let is_m3u8 = downloader.is_m3u8_url(url);
    |                                      ^^^^^^^^^^^ private method
    |
   ::: src\core\downloader.rs:493:5
    |
493 |     fn is_m3u8_url(&self, url: &str) -> bool {
    |     ---------------------------------------- private method defined here

error[E0624]: method `parse_encryption_line` is private
   --> src\core\m3u8_integration_tests.rs:173:14
    |
173 |             .parse_encryption_line(encryption_lines[0])
    |              ^^^^^^^^^^^^^^^^^^^^^ private method
    |
   ::: src\core\m3u8_downloader.rs:384:5
    |
384 |     fn parse_encryption_line(&self, line: &str) -> Result<Option<M3U8Encryption>> {
    |     ----------------------------------------------------------------------------- private method defined here

error[E0624]: method `parse_encryption_line` is private
   --> src\core\m3u8_integration_tests.rs:182:14
    |
182 |             .parse_encryption_line(encryption_lines[1])
    |              ^^^^^^^^^^^^^^^^^^^^^ private method
    |
   ::: src\core\m3u8_downloader.rs:384:5
    |
384 |     fn parse_encryption_line(&self, line: &str) -> Result<Option<M3U8Encryption>> {
    |     ----------------------------------------------------------------------------- private method defined here

error[E0624]: method `parse_encryption_line` is private
   --> src\core\m3u8_integration_tests.rs:195:14
    |
195 |             .parse_encryption_line(encryption_lines[2])
    |              ^^^^^^^^^^^^^^^^^^^^^ private method
    |
   ::: src\core\m3u8_downloader.rs:384:5
    |
384 |     fn parse_encryption_line(&self, line: &str) -> Result<Option<M3U8Encryption>> {
    |     ----------------------------------------------------------------------------- private method defined here

error[E0616]: field `buffer_size` of struct `file_parser::EncodingDetector` is private
   --> src\core\file_parser_tests.rs:136:29
    |
136 |         assert_eq!(detector.buffer_size, 4096);
    |                             ^^^^^^^^^^^ private field

error[E0616]: field `deep_detection` of struct `file_parser::EncodingDetector` is private
   --> src\core\file_parser_tests.rs:137:29
    |
137 |         assert_eq!(detector.deep_detection, true);
    |                             ^^^^^^^^^^^^^^ private field

error[E0616]: field `priority_encodings` of struct `file_parser::EncodingDetector` is private
   --> src\core\file_parser_tests.rs:138:29
    |
138 |         assert_eq!(detector.priority_encodings.len(), 3);
    |                             ^^^^^^^^^^^^^^^^^^ private field

error[E0624]: method `is_reasonable_text` is private
   --> src\core\file_parser_tests.rs:146:26
    |
146 |         assert!(detector.is_reasonable_text("Hello, 涓栫晫! 娴嬭瘯鍐呭銆?));
    |                          ^^^^^^^^^^^^^^^^^^ private method
    |
   ::: src\core\file_parser.rs:307:5
    |
307 |     fn is_reasonable_text(&self, text: &str) -> bool {
    |     ------------------------------------------------ private method defined here

error[E0624]: method `is_reasonable_text` is private
   --> src\core\file_parser_tests.rs:150:27
    |
150 |         assert!(!detector.is_reasonable_text(control_heavy));
    |                           ^^^^^^^^^^^^^^^^^^ private method
    |
   ::: src\core\file_parser.rs:307:5
    |
307 |     fn is_reasonable_text(&self, text: &str) -> bool {
    |     ------------------------------------------------ private method defined here

error[E0624]: method `is_reasonable_text` is private
   --> src\core\file_parser_tests.rs:153:27
    |
153 |         assert!(!detector.is_reasonable_text(""));
    |                           ^^^^^^^^^^^^^^^^^^ private method
    |
   ::: src\core\file_parser.rs:307:5
    |
307 |     fn is_reasonable_text(&self, text: &str) -> bool {
    |     ------------------------------------------------ private method defined here

error[E0624]: method `is_reasonable_text` is private
   --> src\core\file_parser_tests.rs:156:26
    |
156 |         assert!(detector.is_reasonable_text("Hello World"));
    |                          ^^^^^^^^^^^^^^^^^^ private method
    |
   ::: src\core\file_parser.rs:307:5
    |
307 |     fn is_reasonable_text(&self, text: &str) -> bool {
    |     ------------------------------------------------ private method defined here

error[E0624]: method `is_reasonable_text` is private
   --> src\core\file_parser_tests.rs:159:26
    |
159 |         assert!(detector.is_reasonable_text("浣犲ソ涓栫晫"));
    |                          ^^^^^^^^^^^^^^^^^^ private method
    |
   ::: src\core\file_parser.rs:307:5
    |
307 |     fn is_reasonable_text(&self, text: &str) -> bool {
    |     ------------------------------------------------ private method defined here

error[E0624]: method `statistical_chinese_detect` is private
   --> src\core\file_parser_tests.rs:168:33
    |
168 |         let detected = detector.statistical_chinese_detect(gbk_bytes);
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ private method
    |
   ::: src\core\file_parser.rs:364:5
    |
364 |     fn statistical_chinese_detect(&self, data: &[u8]) -> &'static Encoding {
    |     ---------------------------------------------------------------------- private method defined here

error[E0624]: method `detect_bom` is private
   --> src\core\file_parser_tests.rs:180:29
    |
180 |         assert_eq!(detector.detect_bom(utf8_bom), Some(UTF_8));
    |                             ^^^^^^^^^^ private method
    |
   ::: src\core\file_parser.rs:261:5
    |
261 |     fn detect_bom(&self, data: &[u8]) -> Option<&'static Encoding> {
    |     -------------------------------------------------------------- private method defined here

error[E0624]: method `detect_bom` is private
   --> src\core\file_parser_tests.rs:185:22
    |
185 |             detector.detect_bom(utf16le_bom),
    |                      ^^^^^^^^^^ private method
    |
   ::: src\core\file_parser.rs:261:5
    |
261 |     fn detect_bom(&self, data: &[u8]) -> Option<&'static Encoding> {
    |     -------------------------------------------------------------- private method defined here

error[E0624]: method `detect_bom` is private
   --> src\core\file_parser_tests.rs:192:22
    |
192 |             detector.detect_bom(utf16be_bom),
    |                      ^^^^^^^^^^ private method
    |
   ::: src\core\file_parser.rs:261:5
    |
261 |     fn detect_bom(&self, data: &[u8]) -> Option<&'static Encoding> {
    |     -------------------------------------------------------------- private method defined here

error[E0624]: method `detect_bom` is private
   --> src\core\file_parser_tests.rs:198:29
    |
198 |         assert_eq!(detector.detect_bom(no_bom), None);
    |                             ^^^^^^^^^^ private method
    |
   ::: src\core\file_parser.rs:261:5
    |
261 |     fn detect_bom(&self, data: &[u8]) -> Option<&'static Encoding> {
    |     -------------------------------------------------------------- private method defined here

error[E0624]: method `is_gbk_range` is private
   --> src\core\file_parser_tests.rs:206:26
    |
206 |         assert!(detector.is_gbk_range(0x81, 0x40)); // GBK鑼冨洿鍐?    |                          ^^^^^^^^^^^^ private method
    |
   ::: src\core\file_parser.rs:410:5
    |
410 |     fn is_gbk_range(&self, b1: u8, b2: u8) -> bool {
    |     ---------------------------------------------- private method defined here

error[E0624]: method `is_gbk_range` is private
   --> src\core\file_parser_tests.rs:207:26
    |
207 |         assert!(detector.is_gbk_range(0xFE, 0xFE)); // GBK鑼冨洿鍐?    |                          ^^^^^^^^^^^^ private method
    |
   ::: src\core\file_parser.rs:410:5
    |
410 |     fn is_gbk_range(&self, b1: u8, b2: u8) -> bool {
    |     ---------------------------------------------- private method defined here

error[E0624]: method `is_gbk_range` is private
   --> src\core\file_parser_tests.rs:208:27
    |
208 |         assert!(!detector.is_gbk_range(0x80, 0x40)); // 瓒呭嚭鑼冨洿
    |                           ^^^^^^^^^^^^ private method
    |
   ::: src\core\file_parser.rs:410:5
    |
410 |     fn is_gbk_range(&self, b1: u8, b2: u8) -> bool {
    |     ---------------------------------------------- private method defined here

error[E0624]: method `is_gbk_range` is private
   --> src\core\file_parser_tests.rs:209:27
    |
209 |         assert!(!detector.is_gbk_range(0x81, 0x7F)); // 绗簩瀛楄妭鏃犳晥
    |                           ^^^^^^^^^^^^ private method
    |
   ::: src\core\file_parser.rs:410:5
    |
410 |     fn is_gbk_range(&self, b1: u8, b2: u8) -> bool {
    |     ---------------------------------------------- private method defined here

error[E0624]: method `is_big5_range` is private
   --> src\core\file_parser_tests.rs:212:26
    |
212 |         assert!(detector.is_big5_range(0xA1, 0xA1)); // Big5鑼冨洿鍐?    |                          ^^^^^^^^^^^^^ private method
    |
   ::: src\core\file_parser.rs:416:5
    |
416 |     fn is_big5_range(&self, b1: u8, b2: u8) -> bool {
    |     ----------------------------------------------- private method defined here

error[E0624]: method `is_big5_range` is private
   --> src\core\file_parser_tests.rs:213:27
    |
213 |         assert!(!detector.is_big5_range(0x80, 0x40)); // 瓒呭嚭鑼冨洿
    |                           ^^^^^^^^^^^^^ private method
    |
   ::: src\core\file_parser.rs:416:5
    |
416 |     fn is_big5_range(&self, b1: u8, b2: u8) -> bool {
    |     ----------------------------------------------- private method defined here

error[E0624]: method `is_shift_jis_range` is private
   --> src\core\file_parser_tests.rs:216:26
    |
216 |         assert!(detector.is_shift_jis_range(0x81, 0x40)); // Shift-JIS鑼冨洿鍐?    |                          ^^^^^^^^^^^^^^^^^^ private method
    |
   ::: src\core\file_parser.rs:422:5
    |
422 |     fn is_shift_jis_range(&self, b1: u8, b2: u8) -> bool {
    |     ---------------------------------------------------- private method defined here

error[E0624]: method `is_shift_jis_range` is private
   --> src\core\file_parser_tests.rs:217:26
    |
217 |         assert!(detector.is_shift_jis_range(0xE0, 0x80)); // Shift-JIS鑼冨洿鍐?    |                          ^^^^^^^^^^^^^^^^^^ private method
    |
   ::: src\core\file_parser.rs:422:5
    |
422 |     fn is_shift_jis_range(&self, b1: u8, b2: u8) -> bool {
    |     ---------------------------------------------------- private method defined here

error[E0624]: method `is_shift_jis_range` is private
   --> src\core\file_parser_tests.rs:218:27
    |
218 |         assert!(!detector.is_shift_jis_range(0x80, 0x40)); // 瓒呭嚭鑼冨洿
    |                           ^^^^^^^^^^^^^^^^^^ private method
    |
   ::: src\core\file_parser.rs:422:5
    |
422 |     fn is_shift_jis_range(&self, b1: u8, b2: u8) -> bool {
    |     ---------------------------------------------------- private method defined here

error[E0624]: method `detect_file_format` is private
   --> src\core\file_parser_tests.rs:260:14
    |
260 |             .detect_file_format(temp_dir.path().join("utf8_test.csv"))
    |              ^^^^^^^^^^^^^^^^^^ private method
    |
   ::: src\core\file_parser.rs:726:5
    |
726 |     fn detect_file_format<P: AsRef<Path>>(&self, file_path: P) -> Result<FileFormat> {
    |     -------------------------------------------------------------------------------- private method defined here

error[E0624]: method `detect_file_format` is private
   --> src\core\file_parser_tests.rs:267:14
    |
267 |             .detect_file_format(temp_dir.path().join("unknown.txt"))
    |              ^^^^^^^^^^^^^^^^^^ private method
    |
   ::: src\core\file_parser.rs:726:5
    |
726 |     fn detect_file_format<P: AsRef<Path>>(&self, file_path: P) -> Result<FileFormat> {
    |     -------------------------------------------------------------------------------- private method defined here

error[E0624]: method `datatype_to_string` is private
    --> src\core\file_parser_tests.rs:569:20
     |
569  |             parser.datatype_to_string(&DataType::String("test".to_string())),
     |                    ^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1354:5
     |
1354 |     fn datatype_to_string(&self, data: &DataType) -> String {
     |     ------------------------------------------------------- private method defined here

error[E0624]: method `datatype_to_string` is private
    --> src\core\file_parser_tests.rs:572:27
     |
572  |         assert_eq!(parser.datatype_to_string(&DataType::Int(42)), "42");
     |                           ^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1354:5
     |
1354 |     fn datatype_to_string(&self, data: &DataType) -> String {
     |     ------------------------------------------------------- private method defined here

error[E0624]: method `datatype_to_string` is private
    --> src\core\file_parser_tests.rs:573:27
     |
573  |         assert_eq!(parser.datatype_to_string(&DataType::Float(3.14)), "3.14");
     |                           ^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1354:5
     |
1354 |     fn datatype_to_string(&self, data: &DataType) -> String {
     |     ------------------------------------------------------- private method defined here

error[E0624]: method `datatype_to_string` is private
    --> src\core\file_parser_tests.rs:574:27
     |
574  |         assert_eq!(parser.datatype_to_string(&DataType::Float(42.0)), "42");
     |                           ^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1354:5
     |
1354 |     fn datatype_to_string(&self, data: &DataType) -> String {
     |     ------------------------------------------------------- private method defined here

error[E0624]: method `datatype_to_string` is private
    --> src\core\file_parser_tests.rs:575:27
     |
575  |         assert_eq!(parser.datatype_to_string(&DataType::Bool(true)), "true");
     |                           ^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1354:5
     |
1354 |     fn datatype_to_string(&self, data: &DataType) -> String {
     |     ------------------------------------------------------- private method defined here

error[E0624]: method `datatype_to_string` is private
    --> src\core\file_parser_tests.rs:576:27
     |
576  |         assert_eq!(parser.datatype_to_string(&DataType::Empty), "");
     |                           ^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1354:5
     |
1354 |     fn datatype_to_string(&self, data: &DataType) -> String {
     |     ------------------------------------------------------- private method defined here

error[E0624]: method `build_excel_field_mapping` is private
    --> src\core\file_parser_tests.rs:592:36
     |
592  |         let field_mapping = parser.build_excel_field_mapping(&header_row).unwrap();
     |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1211:5
     |
1211 |     fn build_excel_field_mapping(&self, header_row: &[DataType]) -> Result<HashMap<String, usize>> {
     |     ---------------------------------------------------------------------------------------------- private method defined here

error[E0624]: method `is_empty_excel_row` is private
    --> src\core\file_parser_tests.rs:611:24
     |
611  |         assert!(parser.is_empty_excel_row(&empty_row));
     |                        ^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1294:5
     |
1294 |     fn is_empty_excel_row(&self, row: &[DataType]) -> bool {
     |     ------------------------------------------------------ private method defined here

error[E0624]: method `is_empty_excel_row` is private
    --> src\core\file_parser_tests.rs:618:25
     |
618  |         assert!(!parser.is_empty_excel_row(&non_empty_row));
     |                         ^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1294:5
     |
1294 |     fn is_empty_excel_row(&self, row: &[DataType]) -> bool {
     |     ------------------------------------------------------ private method defined here

error[E0624]: method `is_empty_excel_row` is private
    --> src\core\file_parser_tests.rs:625:25
     |
625  |         assert!(!parser.is_empty_excel_row(&mixed_row));
     |                         ^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1294:5
     |
1294 |     fn is_empty_excel_row(&self, row: &[DataType]) -> bool {
     |     ------------------------------------------------------ private method defined here

error[E0624]: method `parse_excel_record` is private
    --> src\core\file_parser_tests.rs:648:14
     |
648  |               .parse_excel_record(&row, &field_mapping, 2, "Sheet1")
     |                ^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1303:5
     |
1303 | /     fn parse_excel_record(
1304 | |         &self,
1305 | |         row: &[DataType],
1306 | |         field_mapping: &HashMap<String, usize>,
1307 | |         row_number: usize,
1308 | |         sheet_name: &str,
1309 | |     ) -> Result<VideoRecord> {
     | |____________________________- private method defined here

error[E0624]: method `parse_excel_record` is private
    --> src\core\file_parser_tests.rs:667:14
     |
667  |               .parse_excel_record(&row_no_column_name, &field_mapping, 3, "鏁版嵁缁撴瀯")
     |                ^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1303:5
     |
1303 | /     fn parse_excel_record(
1304 | |         &self,
1305 | |         row: &[DataType],
1306 | |         field_mapping: &HashMap<String, usize>,
1307 | |         row_number: usize,
1308 | |         sheet_name: &str,
1309 | |     ) -> Result<VideoRecord> {
     | |____________________________- private method defined here

error[E0624]: method `parse_excel_record` is private
    --> src\core\file_parser_tests.rs:680:29
     |
680  |           let result = parser.parse_excel_record(&row_empty_url, &field_mapping, 2, "Sheet1");
     |                               ^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1303:5
     |
1303 | /     fn parse_excel_record(
1304 | |         &self,
1305 | |         row: &[DataType],
1306 | |         field_mapping: &HashMap<String, usize>,
1307 | |         row_number: usize,
1308 | |         sheet_name: &str,
1309 | |     ) -> Result<VideoRecord> {
     | |____________________________- private method defined here

error[E0624]: method `parse_excel_record` is private
    --> src\core\file_parser_tests.rs:686:30
     |
686  |           let result2 = parser.parse_excel_record(&row_invalid_url, &field_mapping, 2, "Sheet1");
     |                                ^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1303:5
     |
1303 | /     fn parse_excel_record(
1304 | |         &self,
1305 | |         row: &[DataType],
1306 | |         field_mapping: &HashMap<String, usize>,
1307 | |         row_number: usize,
1308 | |         sheet_name: &str,
1309 | |     ) -> Result<VideoRecord> {
     | |____________________________- private method defined here

error[E0624]: method `datatype_to_string` is private
    --> src\core\file_parser_tests.rs:699:27
     |
699  |         assert_eq!(parser.datatype_to_string(&DataType::Empty), "");
     |                           ^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1354:5
     |
1354 |     fn datatype_to_string(&self, data: &DataType) -> String {
     |     ------------------------------------------------------- private method defined here

error[E0624]: method `datatype_to_string` is private
    --> src\core\file_parser_tests.rs:701:20
     |
701  |             parser.datatype_to_string(&DataType::String("娴嬭瘯".to_string())),
     |                    ^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1354:5
     |
1354 |     fn datatype_to_string(&self, data: &DataType) -> String {
     |     ------------------------------------------------------- private method defined here

error[E0624]: method `datatype_to_string` is private
    --> src\core\file_parser_tests.rs:704:27
     |
704  |         assert_eq!(parser.datatype_to_string(&DataType::Int(42)), "42");
     |                           ^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1354:5
     |
1354 |     fn datatype_to_string(&self, data: &DataType) -> String {
     |     ------------------------------------------------------- private method defined here

error[E0624]: method `datatype_to_string` is private
    --> src\core\file_parser_tests.rs:705:27
     |
705  |         assert_eq!(parser.datatype_to_string(&DataType::Int(-100)), "-100");
     |                           ^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1354:5
     |
1354 |     fn datatype_to_string(&self, data: &DataType) -> String {
     |     ------------------------------------------------------- private method defined here

error[E0624]: method `datatype_to_string` is private
    --> src\core\file_parser_tests.rs:707:20
     |
707  |             parser.datatype_to_string(&DataType::Float(3.14159)),
     |                    ^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1354:5
     |
1354 |     fn datatype_to_string(&self, data: &DataType) -> String {
     |     ------------------------------------------------------- private method defined here

error[E0624]: method `datatype_to_string` is private
    --> src\core\file_parser_tests.rs:710:27
     |
710  |         assert_eq!(parser.datatype_to_string(&DataType::Float(42.0)), "42"); // 鏁存暟娴偣鏁?     |                           ^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1354:5
     |
1354 |     fn datatype_to_string(&self, data: &DataType) -> String {
     |     ------------------------------------------------------- private method defined here

error[E0624]: method `datatype_to_string` is private
    --> src\core\file_parser_tests.rs:711:27
     |
711  |         assert_eq!(parser.datatype_to_string(&DataType::Float(-0.5)), "-0.5");
     |                           ^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1354:5
     |
1354 |     fn datatype_to_string(&self, data: &DataType) -> String {
     |     ------------------------------------------------------- private method defined here

error[E0624]: method `datatype_to_string` is private
    --> src\core\file_parser_tests.rs:712:27
     |
712  |         assert_eq!(parser.datatype_to_string(&DataType::Bool(true)), "true");
     |                           ^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1354:5
     |
1354 |     fn datatype_to_string(&self, data: &DataType) -> String {
     |     ------------------------------------------------------- private method defined here

error[E0624]: method `datatype_to_string` is private
    --> src\core\file_parser_tests.rs:713:27
     |
713  |         assert_eq!(parser.datatype_to_string(&DataType::Bool(false)), "false");
     |                           ^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1354:5
     |
1354 |     fn datatype_to_string(&self, data: &DataType) -> String {
     |     ------------------------------------------------------- private method defined here

error[E0624]: method `datatype_to_string` is private
    --> src\core\file_parser_tests.rs:717:20
     |
717  |             parser.datatype_to_string(&DataType::Error(calamine::CellErrorType::Div0));
     |                    ^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1354:5
     |
1354 |     fn datatype_to_string(&self, data: &DataType) -> String {
     |     ------------------------------------------------------- private method defined here

error[E0624]: method `build_excel_field_mapping` is private
    --> src\core\file_parser_tests.rs:727:30
     |
727  |         let mapping = parser.build_excel_field_mapping(&empty_headers).unwrap();
     |                              ^^^^^^^^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1211:5
     |
1211 |     fn build_excel_field_mapping(&self, header_row: &[DataType]) -> Result<HashMap<String, usize>> {
     |     ---------------------------------------------------------------------------------------------- private method defined here

error[E0624]: method `build_excel_field_mapping` is private
    --> src\core\file_parser_tests.rs:740:30
     |
740  |         let mapping = parser.build_excel_field_mapping(&mixed_headers).unwrap();
     |                              ^^^^^^^^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1211:5
     |
1211 |     fn build_excel_field_mapping(&self, header_row: &[DataType]) -> Result<HashMap<String, usize>> {
     |     ---------------------------------------------------------------------------------------------- private method defined here

error[E0624]: method `build_excel_field_mapping` is private
    --> src\core\file_parser_tests.rs:761:29
     |
761  |         let result = parser.build_excel_field_mapping(&incomplete_headers);
     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ private method
     |
    ::: src\core\file_parser.rs:1211:5
     |
1211 |     fn build_excel_field_mapping(&self, header_row: &[DataType]) -> Result<HashMap<String, usize>> {
     |     ---------------------------------------------------------------------------------------------- private method defined here

error[E0616]: field `config` of struct `file_parser::FileParser` is private
   --> src\core\file_parser_tests.rs:778:27
    |
778 |         assert_eq!(parser.config.max_rows, 100);
    |                           ^^^^^^ private field

error[E0616]: field `config` of struct `file_parser::FileParser` is private
   --> src\core\file_parser_tests.rs:779:27
    |
779 |         assert_eq!(parser.config.strict_mode, true);
    |                           ^^^^^^ private field

error[E0616]: field `config` of struct `file_parser::FileParser` is private
   --> src\core\file_parser_tests.rs:780:27
    |
780 |         assert_eq!(parser.config.skip_empty_rows, false);
    |                           ^^^^^^ private field

error[E0277]: the trait bound `str: StdError` is not satisfied
   --> src\core\error_handling_integration_tests.rs:61:25
    |
61  |         let _ = breaker.call(async { result1 }).await;
    |                         ^^^^ the trait `StdError` is not implemented for `str`
    |
    = note: required for `&str` to implement `StdError`
note: required by a bound in `error_handling::CircuitBreaker::call`
   --> src\core\error_handling.rs:335:12
    |
332 |     pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    |                  ---- required by a bound in this associated function
...
335 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `CircuitBreaker::call`

error[E0277]: the trait bound `str: StdError` is not satisfied
   --> src\core\error_handling_integration_tests.rs:61:17
    |
61  |         let _ = breaker.call(async { result1 }).await;
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `StdError` is not implemented for `str`
    |
    = note: required for `&str` to implement `StdError`
note: required by a bound in `error_handling::CircuitBreaker::call`
   --> src\core\error_handling.rs:335:12
    |
332 |     pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    |                  ---- required by a bound in this associated function
...
335 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `CircuitBreaker::call`

error[E0277]: the trait bound `str: StdError` is not satisfied
   --> src\core\error_handling_integration_tests.rs:61:49
    |
61  |         let _ = breaker.call(async { result1 }).await;
    |                                                 ^^^^^ the trait `StdError` is not implemented for `str`
    |
    = note: required for `&str` to implement `StdError`
note: required by a bound in `error_handling::CircuitBreaker::call`
   --> src\core\error_handling.rs:335:12
    |
332 |     pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    |                  ---- required by a bound in this associated function
...
335 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `CircuitBreaker::call`

error[E0277]: the trait bound `str: StdError` is not satisfied
   --> src\core\error_handling_integration_tests.rs:65:25
    |
65  |         let _ = breaker.call(async { result2 }).await;
    |                         ^^^^ the trait `StdError` is not implemented for `str`
    |
    = note: required for `&str` to implement `StdError`
note: required by a bound in `error_handling::CircuitBreaker::call`
   --> src\core\error_handling.rs:335:12
    |
332 |     pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    |                  ---- required by a bound in this associated function
...
335 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `CircuitBreaker::call`

error[E0277]: the trait bound `str: StdError` is not satisfied
   --> src\core\error_handling_integration_tests.rs:65:17
    |
65  |         let _ = breaker.call(async { result2 }).await;
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `StdError` is not implemented for `str`
    |
    = note: required for `&str` to implement `StdError`
note: required by a bound in `error_handling::CircuitBreaker::call`
   --> src\core\error_handling.rs:335:12
    |
332 |     pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    |                  ---- required by a bound in this associated function
...
335 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `CircuitBreaker::call`

error[E0277]: the trait bound `str: StdError` is not satisfied
   --> src\core\error_handling_integration_tests.rs:65:49
    |
65  |         let _ = breaker.call(async { result2 }).await;
    |                                                 ^^^^^ the trait `StdError` is not implemented for `str`
    |
    = note: required for `&str` to implement `StdError`
note: required by a bound in `error_handling::CircuitBreaker::call`
   --> src\core\error_handling.rs:335:12
    |
332 |     pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    |                  ---- required by a bound in this associated function
...
335 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `CircuitBreaker::call`

error[E0277]: the trait bound `str: StdError` is not satisfied
   --> src\core\error_handling_integration_tests.rs:70:23
    |
70  |         match breaker.call(async { result3 }).await {
    |                       ^^^^ the trait `StdError` is not implemented for `str`
    |
    = note: required for `&str` to implement `StdError`
note: required by a bound in `error_handling::CircuitBreaker::call`
   --> src\core\error_handling.rs:335:12
    |
332 |     pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    |                  ---- required by a bound in this associated function
...
335 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `CircuitBreaker::call`

error[E0277]: the trait bound `str: StdError` is not satisfied
   --> src\core\error_handling_integration_tests.rs:70:15
    |
70  |         match breaker.call(async { result3 }).await {
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `StdError` is not implemented for `str`
    |
    = note: required for `&str` to implement `StdError`
note: required by a bound in `error_handling::CircuitBreaker::call`
   --> src\core\error_handling.rs:335:12
    |
332 |     pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    |                  ---- required by a bound in this associated function
...
335 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `CircuitBreaker::call`

error[E0277]: the trait bound `str: StdError` is not satisfied
   --> src\core\error_handling_integration_tests.rs:70:47
    |
70  |         match breaker.call(async { result3 }).await {
    |                                               ^^^^^ the trait `StdError` is not implemented for `str`
    |
    = note: required for `&str` to implement `StdError`
note: required by a bound in `error_handling::CircuitBreaker::call`
   --> src\core\error_handling.rs:335:12
    |
332 |     pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    |                  ---- required by a bound in this associated function
...
335 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `CircuitBreaker::call`

error[E0277]: the trait bound `str: StdError` is not satisfied
   --> src\core\error_handling_integration_tests.rs:82:25
    |
82  |         let _ = breaker.call(async { result4 }).await;
    |                         ^^^^ the trait `StdError` is not implemented for `str`
    |
    = note: required for `&str` to implement `StdError`
note: required by a bound in `error_handling::CircuitBreaker::call`
   --> src\core\error_handling.rs:335:12
    |
332 |     pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    |                  ---- required by a bound in this associated function
...
335 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `CircuitBreaker::call`

error[E0277]: the trait bound `str: StdError` is not satisfied
   --> src\core\error_handling_integration_tests.rs:82:17
    |
82  |         let _ = breaker.call(async { result4 }).await;
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `StdError` is not implemented for `str`
    |
    = note: required for `&str` to implement `StdError`
note: required by a bound in `error_handling::CircuitBreaker::call`
   --> src\core\error_handling.rs:335:12
    |
332 |     pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    |                  ---- required by a bound in this associated function
...
335 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `CircuitBreaker::call`

error[E0277]: the trait bound `str: StdError` is not satisfied
   --> src\core\error_handling_integration_tests.rs:82:49
    |
82  |         let _ = breaker.call(async { result4 }).await;
    |                                                 ^^^^^ the trait `StdError` is not implemented for `str`
    |
    = note: required for `&str` to implement `StdError`
note: required by a bound in `error_handling::CircuitBreaker::call`
   --> src\core\error_handling.rs:335:12
    |
332 |     pub async fn call<F, T, E>(&self, f: F) -> Result<T, CircuitBreakerError<E>>
    |                  ---- required by a bound in this associated function
...
335 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `CircuitBreaker::call`

error[E0283]: type annotations needed
   --> src\core\error_handling_integration_tests.rs:164:14
    |
164 |             .execute(|ctx| {
    |              ^^^^^^^ cannot infer type of the type parameter `E` declared on the method `execute`
    |
    = note: cannot satisfy `_: StdError`
note: required by a bound in `error_handling::RetryExecutor::execute`
   --> src\core\error_handling.rs:553:12
    |
545 |     pub async fn execute<F, T, E>(&self, mut f: F) -> AnyhowResult<T>
    |                  ------- required by a bound in this associated function
...
553 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `RetryExecutor::execute`
help: consider specifying the generic arguments
    |
164 |             .execute::<_, std::string::String, E>(|ctx| {
    |                     +++++++++++++++++++++++++++++

error[E0283]: type annotations needed for `Result<_, anyhow::Error>`
   --> src\core\error_handling_integration_tests.rs:195:13
    |
195 |         let result = executor
    |             ^^^^^^
196 |             .execute(|_ctx| {
    |              ------- type must be known at this point
    |
    = note: cannot satisfy `_: std::marker::Send`
note: required by a bound in `error_handling::RetryExecutor::execute`
   --> src\core\error_handling.rs:552:12
    |
545 |     pub async fn execute<F, T, E>(&self, mut f: F) -> AnyhowResult<T>
    |                  ------- required by a bound in this associated function
...
552 |         T: Send + 'static,
    |            ^^^^ required by this bound in `RetryExecutor::execute`
help: consider giving `result` an explicit type, where the type for type parameter `T` is specified
    |
195 |         let result: Result<T, _> = executor
    |                   ++++++++++++++

error[E0283]: type annotations needed
   --> src\core\error_handling_integration_tests.rs:220:14
    |
220 |             .execute(|_ctx| Box::pin(async move { Ok("success".to_string()) }))
    |              ^^^^^^^ cannot infer type of the type parameter `E` declared on the method `execute`
    |
    = note: cannot satisfy `_: StdError`
note: required by a bound in `error_handling::RetryExecutor::execute`
   --> src\core\error_handling.rs:553:12
    |
545 |     pub async fn execute<F, T, E>(&self, mut f: F) -> AnyhowResult<T>
    |                  ------- required by a bound in this associated function
...
553 |         E: std::error::Error + Send + Sync + 'static,
    |            ^^^^^^^^^^^^^^^^^ required by this bound in `RetryExecutor::execute`
help: consider specifying the generic arguments
    |
220 |             .execute::<_, std::string::String, E>(|_ctx| Box::pin(async move { Ok("success".to_string()) }))
    |                     +++++++++++++++++++++++++++++

error[E0624]: method `calculate_delay` is private
   --> src\core\error_handling_integration_tests.rs:266:31
    |
266 |         let delay1 = executor.calculate_delay(&network_error, 1).await;
    |                               ^^^^^^^^^^^^^^^ private method
    |
   ::: src\core\error_handling.rs:640:5
    |
640 |     async fn calculate_delay(&self, error: &DownloadError, attempt: u32) -> Duration {
    |     -------------------------------------------------------------------------------- private method defined here

error[E0624]: method `calculate_delay` is private
   --> src\core\error_handling_integration_tests.rs:267:31
    |
267 |         let delay2 = executor.calculate_delay(&network_error, 2).await;
    |                               ^^^^^^^^^^^^^^^ private method
    |
   ::: src\core\error_handling.rs:640:5
    |
640 |     async fn calculate_delay(&self, error: &DownloadError, attempt: u32) -> Duration {
    |     -------------------------------------------------------------------------------- private method defined here

error[E0624]: method `calculate_delay` is private
   --> src\core\error_handling_integration_tests.rs:268:31
    |
268 |         let delay3 = executor.calculate_delay(&network_error, 3).await;
    |                               ^^^^^^^^^^^^^^^ private method
    |
   ::: src\core\error_handling.rs:640:5
    |
640 |     async fn calculate_delay(&self, error: &DownloadError, attempt: u32) -> Duration {
    |     -------------------------------------------------------------------------------- private method defined here

error[E0624]: method `calculate_delay` is private
   --> src\core\error_handling_integration_tests.rs:275:36
    |
275 |         let delay_large = executor.calculate_delay(&network_error, 10).await;
    |                                    ^^^^^^^^^^^^^^^ private method
    |
   ::: src\core\error_handling.rs:640:5
    |
640 |     async fn calculate_delay(&self, error: &DownloadError, attempt: u32) -> Duration {
    |     -------------------------------------------------------------------------------- private method defined here

error[E0308]: mismatched types
   --> src\core\error_handling_integration_tests.rs:303:43
    |
303 |         let app_error = AppError::Network("Connection failed".to_string());
    |                         ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Error`, found `String`
    |                         |
    |                         arguments to this enum variant are incorrect
    |
note: tuple variant defined here
   --> src\core\models.rs:354:5
    |
354 |     Network(#[from] reqwest::Error),
    |     ^^^^^^^

error[E0624]: associated function `convert_app_error_to_download_error` is private
    --> src\core\error_handling_integration_tests.rs:304:47
     |
304  |         let download_error = DownloadManager::convert_app_error_to_download_error(app_error);
     |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ private associated function
     |
    ::: src\core\manager.rs:1591:5
     |
1591 |     fn convert_app_error_to_download_error(error: AppError) -> DownloadError {
     |     ------------------------------------------------------------------------ private associated function defined here

error[E0624]: associated function `convert_app_error_to_download_error` is private
    --> src\core\error_handling_integration_tests.rs:363:51
     |
363  |             let download_error = DownloadManager::convert_app_error_to_download_error(app_error);
     |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ private associated function
     |
    ::: src\core\manager.rs:1591:5
     |
1591 |     fn convert_app_error_to_download_error(error: AppError) -> DownloadError {
     |     ------------------------------------------------------------------------ private associated function defined here

error[E0599]: no method named `unwrap` found for struct `monitoring::MonitoringSystem` in the current scope
   --> src\core\monitoring_integration_tests.rs:19:56
    |
19  |         let monitoring = MonitoringSystem::new(config).unwrap();
    |                                                        ^^^^^^ method not found in `monitoring::MonitoringSystem`
    |
   ::: src\core\monitoring.rs:321:1
    |
321 | pub struct MonitoringSystem {
    | --------------------------- method `unwrap` not found for this struct
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `unwrap`, perhaps you need to implement it:
            candidate #1: `brotli::enc::threading::OwnedRetriever`

error[E0308]: mismatched types
  --> src\core\monitoring_integration_tests.rs:26:38
   |
26 |             system_metrics_interval: Duration::from_secs(1),
   |                                      ^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `Duration`

error[E0308]: mismatched types
  --> src\core\monitoring_integration_tests.rs:27:38
   |
27 |             download_stats_interval: Duration::from_millis(500),
   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `Duration`

error[E0560]: struct `monitoring::MonitoringConfig` has no field named `performance_metrics_interval`
  --> src\core\monitoring_integration_tests.rs:28:13
   |
28 |             performance_metrics_interval: Duration::from_millis(250),
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unknown field
   |
help: a field with a similar name exists
   |
28 -             performance_metrics_interval: Duration::from_millis(250),
28 +             performance_monitoring_interval: Duration::from_millis(250),
   |

error[E0308]: mismatched types
  --> src\core\monitoring_integration_tests.rs:29:40
   |
29 |             dashboard_update_interval: Duration::from_secs(2),
   |                                        ^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `Duration`

error[E0560]: struct `monitoring::MonitoringConfig` has no field named `history_retention`
  --> src\core\monitoring_integration_tests.rs:30:13
   |
30 |             history_retention: Duration::from_minutes(30),
   |             ^^^^^^^^^^^^^^^^^ `monitoring::MonitoringConfig` does not have this field
   |
   = note: available fields are: `system_metrics_enabled`, `download_stats_enabled`, `performance_monitoring_enabled`, `performance_monitoring_interval`, `dashboard_enabled` ... and 4 others

error[E0599]: no function or associated item named `from_minutes` found for struct `std::time::Duration` in the current scope
  --> src\core\monitoring_integration_tests.rs:30:42
   |
30 |             history_retention: Duration::from_minutes(30),
   |                                          ^^^^^^^^^^^^ function or associated item not found in `std::time::Duration`
   |
note: if you're trying to build a new `std::time::Duration` consider using one of the following associated functions:
      std::time::Duration::new
      std::time::Duration::from_secs
      std::time::Duration::from_millis
      std::time::Duration::from_micros
      and 9 others
  --> /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2\library\core\src\time.rs:194:5
help: there is an associated function `from_micros` with a similar name
   |
30 -             history_retention: Duration::from_minutes(30),
30 +             history_retention: Duration::from_micros(30),
   |

error[E0560]: struct `monitoring::MonitoringConfig` has no field named `max_history_points`
  --> src\core\monitoring_integration_tests.rs:31:13
   |
31 |             max_history_points: 1800,
   |             ^^^^^^^^^^^^^^^^^^ unknown field
   |
help: a field with a similar name exists
   |
31 -             max_history_points: 1800,
31 +             max_historical_points: 1800,
   |

error[E0560]: struct `monitoring::MonitoringConfig` has no field named `enable_prometheus_export`
  --> src\core\monitoring_integration_tests.rs:32:13
   |
32 |             enable_prometheus_export: true,
   |             ^^^^^^^^^^^^^^^^^^^^^^^^ `monitoring::MonitoringConfig` does not have this field
   |
   = note: available fields are: `system_metrics_enabled`, `download_stats_enabled`, `performance_monitoring_enabled`, `performance_monitoring_interval`, `dashboard_enabled` ... and 4 others

error[E0560]: struct `monitoring::MonitoringConfig` has no field named `prometheus_port`
  --> src\core\monitoring_integration_tests.rs:33:13
   |
33 |             prometheus_port: 9091,
   |             ^^^^^^^^^^^^^^^ `monitoring::MonitoringConfig` does not have this field
   |
   = note: available fields are: `system_metrics_enabled`, `download_stats_enabled`, `performance_monitoring_enabled`, `performance_monitoring_interval`, `dashboard_enabled` ... and 4 others

error[E0560]: struct `monitoring::MonitoringConfig` has no field named `enable_websocket_dashboard`
  --> src\core\monitoring_integration_tests.rs:34:13
   |
34 |             enable_websocket_dashboard: true,
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ `monitoring::MonitoringConfig` does not have this field
   |
   = note: available fields are: `system_metrics_enabled`, `download_stats_enabled`, `performance_monitoring_enabled`, `performance_monitoring_interval`, `dashboard_enabled` ... and 4 others

error[E0560]: struct `monitoring::MonitoringConfig` has no field named `websocket_port`
  --> src\core\monitoring_integration_tests.rs:35:13
   |
35 |             websocket_port: 8081,
   |             ^^^^^^^^^^^^^^ `monitoring::MonitoringConfig` does not have this field
   |
   = note: available fields are: `system_metrics_enabled`, `download_stats_enabled`, `performance_monitoring_enabled`, `performance_monitoring_interval`, `dashboard_enabled` ... and 4 others

error[E0560]: struct `monitoring::MonitoringConfig` has no field named `health_check_interval`
  --> src\core\monitoring_integration_tests.rs:36:13
   |
36 |             health_check_interval: Duration::from_secs(5),
   |             ^^^^^^^^^^^^^^^^^^^^^ `monitoring::MonitoringConfig` does not have this field
   |
   = note: available fields are: `system_metrics_enabled`, `download_stats_enabled`, `performance_monitoring_enabled`, `performance_monitoring_interval`, `dashboard_enabled` ... and 4 others

error[E0560]: struct `monitoring::MonitoringConfig` has no field named `alert_rules`
  --> src\core\monitoring_integration_tests.rs:37:13
   |
37 |             alert_rules: vec![],
   |             ^^^^^^^^^^^ `monitoring::MonitoringConfig` does not have this field
   |
   = note: available fields are: `system_metrics_enabled`, `download_stats_enabled`, `performance_monitoring_enabled`, `performance_monitoring_interval`, `dashboard_enabled` ... and 4 others

error[E0599]: no method named `unwrap` found for struct `monitoring::MonitoringSystem` in the current scope
   --> src\core\monitoring_integration_tests.rs:40:70
    |
40  |         let custom_monitoring = MonitoringSystem::new(custom_config).unwrap();
    |                                                                      ^^^^^^ method not found in `monitoring::MonitoringSystem`
    |
   ::: src\core\monitoring.rs:321:1
    |
321 | pub struct MonitoringSystem {
    | --------------------------- method `unwrap` not found for this struct
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `unwrap`, perhaps you need to implement it:
            candidate #1: `brotli::enc::threading::OwnedRetriever`

error[E0599]: no method named `unwrap` found for struct `monitoring::MonitoringSystem` in the current scope
   --> src\core\monitoring_integration_tests.rs:51:56
    |
51  |         let monitoring = MonitoringSystem::new(config).unwrap();
    |                                                        ^^^^^^ method not found in `monitoring::MonitoringSystem`
    |
   ::: src\core\monitoring.rs:321:1
    |
321 | pub struct MonitoringSystem {
    | --------------------------- method `unwrap` not found for this struct
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `unwrap`, perhaps you need to implement it:
            candidate #1: `brotli::enc::threading::OwnedRetriever`

error[E0599]: no method named `unwrap` found for struct `monitoring::MonitoringSystem` in the current scope
   --> src\core\monitoring_integration_tests.rs:80:56
    |
80  |         let monitoring = MonitoringSystem::new(config).unwrap();
    |                                                        ^^^^^^ method not found in `monitoring::MonitoringSystem`
    |
   ::: src\core\monitoring.rs:321:1
    |
321 | pub struct MonitoringSystem {
    | --------------------------- method `unwrap` not found for this struct
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `unwrap`, perhaps you need to implement it:
            candidate #1: `brotli::enc::threading::OwnedRetriever`

error[E0560]: struct `monitoring::MonitoringConfig` has no field named `performance_metrics_interval`
   --> src\core\monitoring_integration_tests.rs:119:13
    |
119 |             performance_metrics_interval: Duration::from_millis(50),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unknown field
    |
help: a field with a similar name exists
    |
119 -             performance_metrics_interval: Duration::from_millis(50),
119 +             performance_monitoring_interval: Duration::from_millis(50),
    |

error[E0599]: no method named `unwrap` found for struct `monitoring::MonitoringSystem` in the current scope
   --> src\core\monitoring_integration_tests.rs:123:56
    |
123 |         let monitoring = MonitoringSystem::new(config).unwrap();
    |                                                        ^^^^^^ method not found in `monitoring::MonitoringSystem`
    |
   ::: src\core\monitoring.rs:321:1
    |
321 | pub struct MonitoringSystem {
    | --------------------------- method `unwrap` not found for this struct
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `unwrap`, perhaps you need to implement it:
            candidate #1: `brotli::enc::threading::OwnedRetriever`

error[E0560]: struct `monitoring::MonitoringConfig` has no field named `health_check_interval`
   --> src\core\monitoring_integration_tests.rs:147:13
    |
147 |             health_check_interval: Duration::from_millis(100),
    |             ^^^^^^^^^^^^^^^^^^^^^ `monitoring::MonitoringConfig` does not have this field
    |
    = note: available fields are: `system_metrics_enabled`, `download_stats_enabled`, `download_stats_interval`, `performance_monitoring_enabled`, `performance_monitoring_interval` ... and 6 others

error[E0599]: no method named `unwrap` found for struct `monitoring::MonitoringSystem` in the current scope
   --> src\core\monitoring_integration_tests.rs:152:56
    |
152 |         let monitoring = MonitoringSystem::new(config).unwrap();
    |                                                        ^^^^^^ method not found in `monitoring::MonitoringSystem`
    |
   ::: src\core\monitoring.rs:321:1
    |
321 | pub struct MonitoringSystem {
    | --------------------------- method `unwrap` not found for this struct
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `unwrap`, perhaps you need to implement it:
            candidate #1: `brotli::enc::threading::OwnedRetriever`

error[E0308]: mismatched types
   --> src\core\monitoring_integration_tests.rs:186:40
    |
186 |             dashboard_update_interval: Duration::from_millis(100),
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `Duration`

error[E0308]: mismatched types
   --> src\core\monitoring_integration_tests.rs:187:38
    |
187 |             system_metrics_interval: Duration::from_millis(50),
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `Duration`

error[E0308]: mismatched types
   --> src\core\monitoring_integration_tests.rs:188:38
    |
188 |             download_stats_interval: Duration::from_millis(50),
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `Duration`

error[E0560]: struct `monitoring::MonitoringConfig` has no field named `performance_metrics_interval`
   --> src\core\monitoring_integration_tests.rs:189:13
    |
189 |             performance_metrics_interval: Duration::from_millis(50),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unknown field
    |
help: a field with a similar name exists
    |
189 -             performance_metrics_interval: Duration::from_millis(50),
189 +             performance_monitoring_interval: Duration::from_millis(50),
    |

error[E0599]: no method named `unwrap` found for struct `monitoring::MonitoringSystem` in the current scope
   --> src\core\monitoring_integration_tests.rs:193:56
    |
193 |         let monitoring = MonitoringSystem::new(config).unwrap();
    |                                                        ^^^^^^ method not found in `monitoring::MonitoringSystem`
    |
   ::: src\core\monitoring.rs:321:1
    |
321 | pub struct MonitoringSystem {
    | --------------------------- method `unwrap` not found for this struct
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `unwrap`, perhaps you need to implement it:
            candidate #1: `brotli::enc::threading::OwnedRetriever`

error[E0560]: struct `monitoring::MonitoringConfig` has no field named `enable_prometheus_export`
   --> src\core\monitoring_integration_tests.rs:222:13
    |
222 |             enable_prometheus_export: true,
    |             ^^^^^^^^^^^^^^^^^^^^^^^^ `monitoring::MonitoringConfig` does not have this field
    |
    = note: available fields are: `system_metrics_enabled`, `download_stats_enabled`, `performance_monitoring_enabled`, `performance_monitoring_interval`, `dashboard_enabled` ... and 5 others

error[E0560]: struct `monitoring::MonitoringConfig` has no field named `prometheus_port`
   --> src\core\monitoring_integration_tests.rs:223:13
    |
223 |             prometheus_port: 9092, // Use different port to avoid conflicts
    |             ^^^^^^^^^^^^^^^ `monitoring::MonitoringConfig` does not have this field
    |
    = note: available fields are: `system_metrics_enabled`, `download_stats_enabled`, `performance_monitoring_enabled`, `performance_monitoring_interval`, `dashboard_enabled` ... and 5 others

error[E0308]: mismatched types
   --> src\core\monitoring_integration_tests.rs:224:38
    |
224 |             system_metrics_interval: Duration::from_millis(50),
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `Duration`

error[E0599]: no method named `unwrap` found for struct `monitoring::MonitoringSystem` in the current scope
   --> src\core\monitoring_integration_tests.rs:229:56
    |
229 |         let monitoring = MonitoringSystem::new(config).unwrap();
    |                                                        ^^^^^^ method not found in `monitoring::MonitoringSystem`
    |
   ::: src\core\monitoring.rs:321:1
    |
321 | pub struct MonitoringSystem {
    | --------------------------- method `unwrap` not found for this struct
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `unwrap`, perhaps you need to implement it:
            candidate #1: `brotli::enc::threading::OwnedRetriever`

error[E0560]: struct `monitoring::MonitoringConfig` has no field named `enable_websocket_dashboard`
   --> src\core\monitoring_integration_tests.rs:262:13
    |
262 |             enable_websocket_dashboard: true,
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ `monitoring::MonitoringConfig` does not have this field
    |
    = note: available fields are: `system_metrics_enabled`, `download_stats_enabled`, `download_stats_interval`, `performance_monitoring_enabled`, `performance_monitoring_interval` ... and 5 others

error[E0560]: struct `monitoring::MonitoringConfig` has no field named `websocket_port`
   --> src\core\monitoring_integration_tests.rs:263:13
    |
263 |             websocket_port: 8082, // Use different port to avoid conflicts
    |             ^^^^^^^^^^^^^^ `monitoring::MonitoringConfig` does not have this field
    |
    = note: available fields are: `system_metrics_enabled`, `download_stats_enabled`, `download_stats_interval`, `performance_monitoring_enabled`, `performance_monitoring_interval` ... and 5 others

error[E0308]: mismatched types
   --> src\core\monitoring_integration_tests.rs:264:40
    |
264 |             dashboard_update_interval: Duration::from_millis(100),
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `Duration`

error[E0599]: no method named `unwrap` found for struct `monitoring::MonitoringSystem` in the current scope
   --> src\core\monitoring_integration_tests.rs:269:56
    |
269 |         let monitoring = MonitoringSystem::new(config).unwrap();
    |                                                        ^^^^^^ method not found in `monitoring::MonitoringSystem`
    |
   ::: src\core\monitoring.rs:321:1
    |
321 | pub struct MonitoringSystem {
    | --------------------------- method `unwrap` not found for this struct
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `unwrap`, perhaps you need to implement it:
            candidate #1: `brotli::enc::threading::OwnedRetriever`

error[E0599]: no method named `get_system_metrics` found for struct `manager::DownloadManager` in the current scope
   --> src\core\monitoring_integration_tests.rs:311:38
    |
311 |         let system_metrics = manager.get_system_metrics().await;
    |                                      ^^^^^^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_system_metrics` not found for this struct
    |
help: there is a method `get_prometheus_metrics` with a similar name
    |
311 -         let system_metrics = manager.get_system_metrics().await;
311 +         let system_metrics = manager.get_prometheus_metrics().await;
    |

error[E0308]: mismatched types
   --> src\core\monitoring_integration_tests.rs:338:38
    |
338 |             system_metrics_interval: Duration::from_millis(10),
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `Duration`

error[E0308]: mismatched types
   --> src\core\monitoring_integration_tests.rs:339:38
    |
339 |             download_stats_interval: Duration::from_millis(10),
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `Duration`

error[E0560]: struct `monitoring::MonitoringConfig` has no field named `performance_metrics_interval`
   --> src\core\monitoring_integration_tests.rs:340:13
    |
340 |             performance_metrics_interval: Duration::from_millis(10),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unknown field
    |
help: a field with a similar name exists
    |
340 -             performance_metrics_interval: Duration::from_millis(10),
340 +             performance_monitoring_interval: Duration::from_millis(10),
    |

error[E0308]: mismatched types
   --> src\core\monitoring_integration_tests.rs:341:40
    |
341 |             dashboard_update_interval: Duration::from_millis(20),
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `Duration`

error[E0560]: struct `monitoring::MonitoringConfig` has no field named `max_history_points`
   --> src\core\monitoring_integration_tests.rs:342:13
    |
342 |             max_history_points: 100, // Small history for test
    |             ^^^^^^^^^^^^^^^^^^ unknown field
    |
help: a field with a similar name exists
    |
342 -             max_history_points: 100, // Small history for test
342 +             max_historical_points: 100, // Small history for test
    |

error[E0599]: no method named `unwrap` found for struct `monitoring::MonitoringSystem` in the current scope
   --> src\core\monitoring_integration_tests.rs:346:56
    |
346 |         let monitoring = MonitoringSystem::new(config).unwrap();
    |                                                        ^^^^^^ method not found in `monitoring::MonitoringSystem`
    |
   ::: src\core\monitoring.rs:321:1
    |
321 | pub struct MonitoringSystem {
    | --------------------------- method `unwrap` not found for this struct
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `unwrap`, perhaps you need to implement it:
            candidate #1: `brotli::enc::threading::OwnedRetriever`

error[E0560]: struct `monitoring::MonitoringConfig` has no field named `prometheus_port`
   --> src\core\monitoring_integration_tests.rs:380:13
    |
380 |             prometheus_port: 0, // Invalid port
    |             ^^^^^^^^^^^^^^^ `monitoring::MonitoringConfig` does not have this field
    |
    = note: available fields are: `system_metrics_enabled`, `system_metrics_interval`, `download_stats_enabled`, `download_stats_interval`, `performance_monitoring_enabled` ... and 7 others

error[E0560]: struct `monitoring::MonitoringConfig` has no field named `websocket_port`
   --> src\core\monitoring_integration_tests.rs:381:13
    |
381 |             websocket_port: 0,  // Invalid port
    |             ^^^^^^^^^^^^^^ `monitoring::MonitoringConfig` does not have this field
    |
    = note: available fields are: `system_metrics_enabled`, `system_metrics_interval`, `download_stats_enabled`, `download_stats_interval`, `performance_monitoring_enabled` ... and 7 others

error[E0599]: no method named `is_err` found for struct `monitoring::MonitoringSystem` in the current scope
   --> src\core\monitoring_integration_tests.rs:386:28
    |
386 |         assert!(monitoring.is_err()); // Should fail with invalid config
    |                            ^^^^^^ method not found in `monitoring::MonitoringSystem`
    |
   ::: src\core\monitoring.rs:321:1
    |
321 | pub struct MonitoringSystem {
    | --------------------------- method `is_err` not found for this struct

error[E0599]: no method named `unwrap` found for struct `monitoring::MonitoringSystem` in the current scope
   --> src\core\monitoring_integration_tests.rs:390:62
    |
390 |         let monitoring = MonitoringSystem::new(valid_config).unwrap();
    |                                                              ^^^^^^ method not found in `monitoring::MonitoringSystem`
    |
   ::: src\core\monitoring.rs:321:1
    |
321 | pub struct MonitoringSystem {
    | --------------------------- method `unwrap` not found for this struct
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `unwrap`, perhaps you need to implement it:
            candidate #1: `brotli::enc::threading::OwnedRetriever`

error[E0599]: no method named `unwrap` found for struct `monitoring::MonitoringSystem` in the current scope
   --> src\core\monitoring_integration_tests.rs:395:77
    |
395 |         let monitoring = MonitoringSystem::new(MonitoringConfig::default()).unwrap();
    |                                                                             ^^^^^^ method not found in `monitoring::MonitoringSystem`
    |
   ::: src\core\monitoring.rs:321:1
    |
321 | pub struct MonitoringSystem {
    | --------------------------- method `unwrap` not found for this struct
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `unwrap`, perhaps you need to implement it:
            candidate #1: `brotli::enc::threading::OwnedRetriever`

error[E0277]: `youtube_downloader::YoutubeDownloader` doesn't implement `Debug`
  --> src\core\youtube_downloader_integration_tests.rs:36:14
   |
36 |             .unwrap_err()
   |              ^^^^^^^^^^ the trait `Debug` is not implemented for `youtube_downloader::YoutubeDownloader`
   |
   = note: add `#[derive(Debug)]` to `youtube_downloader::YoutubeDownloader` or manually `impl Debug for youtube_downloader::YoutubeDownloader`
note: required by a bound in `Result::<T, E>::unwrap_err`
  --> /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2\library\core\src\result.rs:1256:5
help: consider annotating `youtube_downloader::YoutubeDownloader` with `#[derive(Debug)]`
  --> src\core\youtube_downloader.rs:221:1
   |
221+ #[derive(Debug)]
222| pub struct YoutubeDownloader {
   |

error[E0624]: method `is_youtube_url` is private
   --> src\core\youtube_downloader_integration_tests.rs:47:28
    |
47  |         assert!(downloader.is_youtube_url("https://www.youtube.com/watch?v=dQw4w9WgXcQ"));
    |                            ^^^^^^^^^^^^^^ private method
    |
   ::: src\core\youtube_downloader.rs:558:5
    |
558 |     fn is_youtube_url(&self, url: &str) -> bool {
    |     ------------------------------------------- private method defined here

error[E0624]: method `is_youtube_url` is private
   --> src\core\youtube_downloader_integration_tests.rs:48:28
    |
48  |         assert!(downloader.is_youtube_url("https://youtu.be/dQw4w9WgXcQ"));
    |                            ^^^^^^^^^^^^^^ private method
    |
   ::: src\core\youtube_downloader.rs:558:5
    |
558 |     fn is_youtube_url(&self, url: &str) -> bool {
    |     ------------------------------------------- private method defined here

error[E0624]: method `is_youtube_url` is private
   --> src\core\youtube_downloader_integration_tests.rs:49:28
    |
49  |         assert!(downloader.is_youtube_url("https://m.youtube.com/watch?v=dQw4w9WgXcQ"));
    |                            ^^^^^^^^^^^^^^ private method
    |
   ::: src\core\youtube_downloader.rs:558:5
    |
558 |     fn is_youtube_url(&self, url: &str) -> bool {
    |     ------------------------------------------- private method defined here

error[E0624]: method `is_youtube_url` is private
   --> src\core\youtube_downloader_integration_tests.rs:50:28
    |
50  |         assert!(downloader.is_youtube_url("http://youtube.com/watch?v=test123"));
    |                            ^^^^^^^^^^^^^^ private method
    |
   ::: src\core\youtube_downloader.rs:558:5
    |
558 |     fn is_youtube_url(&self, url: &str) -> bool {
    |     ------------------------------------------- private method defined here

error[E0624]: method `is_youtube_url` is private
   --> src\core\youtube_downloader_integration_tests.rs:53:29
    |
53  |         assert!(!downloader.is_youtube_url("https://example.com/video"));
    |                             ^^^^^^^^^^^^^^ private method
    |
   ::: src\core\youtube_downloader.rs:558:5
    |
558 |     fn is_youtube_url(&self, url: &str) -> bool {
    |     ------------------------------------------- private method defined here

error[E0624]: method `is_youtube_url` is private
   --> src\core\youtube_downloader_integration_tests.rs:54:29
    |
54  |         assert!(!downloader.is_youtube_url("https://vimeo.com/123456"));
    |                             ^^^^^^^^^^^^^^ private method
    |
   ::: src\core\youtube_downloader.rs:558:5
    |
558 |     fn is_youtube_url(&self, url: &str) -> bool {
    |     ------------------------------------------- private method defined here

error[E0624]: method `is_youtube_url` is private
   --> src\core\youtube_downloader_integration_tests.rs:55:29
    |
55  |         assert!(!downloader.is_youtube_url("not_a_url"));
    |                             ^^^^^^^^^^^^^^ private method
    |
   ::: src\core\youtube_downloader.rs:558:5
    |
558 |     fn is_youtube_url(&self, url: &str) -> bool {
    |     ------------------------------------------- private method defined here

error[E0624]: method `is_youtube_url` is private
   --> src\core\youtube_downloader_integration_tests.rs:56:29
    |
56  |         assert!(!downloader.is_youtube_url(""));
    |                             ^^^^^^^^^^^^^^ private method
    |
   ::: src\core\youtube_downloader.rs:558:5
    |
558 |     fn is_youtube_url(&self, url: &str) -> bool {
    |     ------------------------------------------- private method defined here

error[E0308]: mismatched types
  --> src\core\system_integration_tests.rs:77:31
   |
77 |             output_directory: test_config.downloads_dir.clone(),
   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found `PathBuf`

error[E0063]: missing fields `headers` and `proxy` in initializer of `models::DownloadConfig`
  --> src\core\system_integration_tests.rs:72:35
   |
72 |         let mut download_config = DownloadConfig {
   |                                   ^^^^^^^^^^^^^^ missing `headers` and `proxy`

error[E0616]: field `is_running` of struct `manager::DownloadManager` is private
  --> src\core\system_integration_tests.rs:87:25
   |
87 |         assert!(manager.is_running == false);
   |                         ^^^^^^^^^^ private field

error[E0616]: field `is_running` of struct `manager::DownloadManager` is private
  --> src\core\system_integration_tests.rs:89:25
   |
89 |         assert!(manager.is_running == true);
   |                         ^^^^^^^^^^ private field

error[E0599]: no method named `get_config` found for struct `manager::DownloadManager` in the current scope
   --> src\core\system_integration_tests.rs:97:38
    |
97  |         let initial_config = manager.get_config().clone();
    |                                      ^^^^^^^^^^ method not found in `manager::DownloadManager`
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_config` not found for this struct

error[E0599]: no method named `get_config` found for struct `manager::DownloadManager` in the current scope
   --> src\core\system_integration_tests.rs:105:36
    |
105 |         let final_config = manager.get_config().clone();
    |                                    ^^^^^^^^^^ method not found in `manager::DownloadManager`
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_config` not found for this struct

error[E0560]: struct `file_parser::FileParserConfig` has no field named `encoding_detection`
   --> src\core\system_integration_tests.rs:111:13
    |
111 |             encoding_detection: true,
    |             ^^^^^^^^^^^^^^^^^^ `file_parser::FileParserConfig` does not have this field
    |
    = note: available fields are: `strict_mode`, `max_rows`, `skip_empty_rows`, `csv_delimiter`

error[E0560]: struct `file_parser::FieldMapping` has no field named `column_id_field`
   --> src\core\system_integration_tests.rs:113:17
    |
113 |                 column_id_field: "zl_id".to_string(),
    |                 ^^^^^^^^^^^^^^^ unknown field
    |
help: a field with a similar name exists
    |
113 -                 column_id_field: "zl_id".to_string(),
113 +                 column_id_names: "zl_id".to_string(),
    |

error[E0560]: struct `file_parser::FieldMapping` has no field named `column_name_field`
   --> src\core\system_integration_tests.rs:114:17
    |
114 |                 column_name_field: "zl_name".to_string(),
    |                 ^^^^^^^^^^^^^^^^^ unknown field
    |
help: a field with a similar name exists
    |
114 -                 column_name_field: "zl_name".to_string(),
114 +                 column_name_names: "zl_name".to_string(),
    |

error[E0560]: struct `file_parser::FieldMapping` has no field named `video_url_field`
   --> src\core\system_integration_tests.rs:115:17
    |
115 |                 video_url_field: "record_url".to_string(),
    |                 ^^^^^^^^^^^^^^^ unknown field
    |
help: a field with a similar name exists
    |
115 -                 video_url_field: "record_url".to_string(),
115 +                 video_url_names: "record_url".to_string(),
    |

error[E0560]: struct `file_parser::FieldMapping` has no field named `course_id_field`
   --> src\core\system_integration_tests.rs:116:17
    |
116 |                 course_id_field: "kc_id".to_string(),
    |                 ^^^^^^^^^^^^^^^ unknown field
    |
help: a field with a similar name exists
    |
116 -                 course_id_field: "kc_id".to_string(),
116 +                 course_id_names: "kc_id".to_string(),
    |

error[E0560]: struct `file_parser::FieldMapping` has no field named `course_name_field`
   --> src\core\system_integration_tests.rs:117:17
    |
117 |                 course_name_field: "kc_name".to_string(),
    |                 ^^^^^^^^^^^^^^^^^ unknown field
    |
help: a field with a similar name exists
    |
117 -                 course_name_field: "kc_name".to_string(),
117 +                 course_name_names: "kc_name".to_string(),
    |

error[E0560]: struct `file_parser::FileParserConfig` has no field named `validate_urls`
   --> src\core\system_integration_tests.rs:119:13
    |
119 |             validate_urls: true,
    |             ^^^^^^^^^^^^^ `file_parser::FileParserConfig` does not have this field
    |
    = note: available fields are: `strict_mode`, `max_rows`, `skip_empty_rows`, `csv_delimiter`

error[E0560]: struct `file_parser::FileParserConfig` has no field named `max_records`
   --> src\core\system_integration_tests.rs:120:13
    |
120 |             max_records: Some(1000),
    |             ^^^^^^^^^^^ `file_parser::FileParserConfig` does not have this field
    |
    = note: available fields are: `strict_mode`, `max_rows`, `skip_empty_rows`, `csv_delimiter`

error[E0061]: this function takes 0 arguments but 1 argument was supplied
   --> src\core\system_integration_tests.rs:123:27
    |
123 |         let file_parser = FileParser::new(file_parser_config)?;
    |                           ^^^^^^^^^^^^^^^ ------------------ unexpected argument of type `file_parser::FileParserConfig`
    |
note: associated function defined here
   --> src\core\file_parser.rs:463:12
    |
463 |     pub fn new() -> Self {
    |            ^^^
help: remove the extra argument
    |
123 -         let file_parser = FileParser::new(file_parser_config)?;
123 +         let file_parser = FileParser::new()?;
    |

error[E0277]: the `?` operator can only be applied to values that implement `Try`
   --> src\core\system_integration_tests.rs:123:27
    |
123 |         let file_parser = FileParser::new(file_parser_config)?;
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the `?` operator cannot be applied to type `file_parser::FileParser`
    |
    = help: the trait `Try` is not implemented for `file_parser::FileParser`

error[E0599]: no method named `get_system_metrics` found for struct `manager::DownloadManager` in the current scope
   --> src\core\system_integration_tests.rs:195:38
    |
195 |         let system_metrics = manager.get_system_metrics().await;
    |                                      ^^^^^^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_system_metrics` not found for this struct
    |
help: there is a method `get_prometheus_metrics` with a similar name
    |
195 -         let system_metrics = manager.get_system_metrics().await;
195 +         let system_metrics = manager.get_prometheus_metrics().await;
    |

error[E0599]: no method named `computed_hash` found for struct `integrity_checker::IntegrityResult` in the current scope
   --> src\core\system_integration_tests.rs:238:34
    |
238 |         assert!(integrity_result.computed_hash().is_some());
    |                                  ^^^^^^^^^^^^^-- help: remove the arguments
    |                                  |
    |                                  field, not a method
    |
   ::: src\core\integrity_checker.rs:127:1
    |
127 | pub struct IntegrityResult {
    | -------------------------- method `computed_hash` not found for this struct

error[E0599]: no method named `computed_hash` found for struct `integrity_checker::IntegrityResult` in the current scope
   --> src\core\system_integration_tests.rs:239:35
    |
239 |         assert!(!integrity_result.computed_hash().unwrap().is_empty());
    |                                   ^^^^^^^^^^^^^-- help: remove the arguments
    |                                   |
    |                                   field, not a method
    |
   ::: src\core\integrity_checker.rs:127:1
    |
127 | pub struct IntegrityResult {
    | -------------------------- method `computed_hash` not found for this struct

error[E0599]: no method named `get_config` found for struct `manager::DownloadManager` in the current scope
   --> src\core\system_integration_tests.rs:259:37
    |
259 |         let config_before = manager.get_config().clone();
    |                                     ^^^^^^^^^^ method not found in `manager::DownloadManager`
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_config` not found for this struct

error[E0599]: no method named `get_system_metrics` found for struct `manager::DownloadManager` in the current scope
   --> src\core\system_integration_tests.rs:313:44
    |
313 |         let final_system_metrics = manager.get_system_metrics().await;
    |                                            ^^^^^^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_system_metrics` not found for this struct
    |
help: there is a method `get_prometheus_metrics` with a similar name
    |
313 -         let final_system_metrics = manager.get_system_metrics().await;
313 +         let final_system_metrics = manager.get_prometheus_metrics().await;
    |

error[E0616]: field `is_running` of struct `manager::DownloadManager` is private
   --> src\core\system_integration_tests.rs:334:26
    |
334 |         assert!(!manager.is_running);
    |                          ^^^^^^^^^^ private field

error[E0599]: no method named `get_system_metrics` found for struct `manager::DownloadManager` in the current scope
   --> src\core\system_integration_tests.rs:432:38
    |
432 |         let system_metrics = manager.get_system_metrics().await;
    |                                      ^^^^^^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_system_metrics` not found for this struct
    |
help: there is a method `get_prometheus_metrics` with a similar name
    |
432 -         let system_metrics = manager.get_system_metrics().await;
432 +         let system_metrics = manager.get_prometheus_metrics().await;
    |

error[E0308]: mismatched types
   --> src\core\system_integration_tests.rs:507:31
    |
507 |             output_directory: test_config.downloads_dir.clone(),
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found `PathBuf`

error[E0061]: this function takes 0 arguments but 1 argument was supplied
   --> src\core\system_integration_tests.rs:545:27
    |
545 |         let file_parser = FileParser::new(file_parser_config)?;
    |                           ^^^^^^^^^^^^^^^ ------------------ unexpected argument of type `file_parser::FileParserConfig`
    |
note: associated function defined here
   --> src\core\file_parser.rs:463:12
    |
463 |     pub fn new() -> Self {
    |            ^^^
help: remove the extra argument
    |
545 -         let file_parser = FileParser::new(file_parser_config)?;
545 +         let file_parser = FileParser::new()?;
    |

error[E0277]: the `?` operator can only be applied to values that implement `Try`
   --> src\core\system_integration_tests.rs:545:27
    |
545 |         let file_parser = FileParser::new(file_parser_config)?;
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the `?` operator cannot be applied to type `file_parser::FileParser`
    |
    = help: the trait `Try` is not implemented for `file_parser::FileParser`

error[E0599]: no method named `get_system_metrics` found for struct `manager::DownloadManager` in the current scope
   --> src\core\system_integration_tests.rs:556:41
    |
556 |         let monitoring_active = manager.get_system_metrics().await.is_some();
    |                                         ^^^^^^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_system_metrics` not found for this struct
    |
help: there is a method `get_prometheus_metrics` with a similar name
    |
556 -         let monitoring_active = manager.get_system_metrics().await.is_some();
556 +         let monitoring_active = manager.get_prometheus_metrics().await.is_some();
    |

error[E0599]: no method named `computed_hash` found for struct `integrity_checker::IntegrityResult` in the current scope
   --> src\core\system_integration_tests.rs:610:34
    |
610 |         assert!(integrity_result.computed_hash().is_some());
    |                                  ^^^^^^^^^^^^^-- help: remove the arguments
    |                                  |
    |                                  field, not a method
    |
   ::: src\core\integrity_checker.rs:127:1
    |
127 | pub struct IntegrityResult {
    | -------------------------- method `computed_hash` not found for this struct

error[E0599]: no method named `get_config` found for struct `manager::DownloadManager` in the current scope
   --> src\core\system_integration_tests.rs:613:39
    |
613 |         let original_config = manager.get_config().clone();
    |                                       ^^^^^^^^^^ method not found in `manager::DownloadManager`
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_config` not found for this struct

error[E0599]: no method named `get_config` found for struct `manager::DownloadManager` in the current scope
   --> src\core\system_integration_tests.rs:620:38
    |
620 |         let updated_config = manager.get_config().clone();
    |                                      ^^^^^^^^^^ method not found in `manager::DownloadManager`
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_config` not found for this struct

error[E0599]: no method named `get_system_metrics` found for struct `manager::DownloadManager` in the current scope
   --> src\core\system_integration_tests.rs:626:44
    |
626 |         let final_system_metrics = manager.get_system_metrics().await;
    |                                            ^^^^^^^^^^^^^^^^^^
    |
   ::: src\core\manager.rs:197:1
    |
197 | pub struct DownloadManager {
    | -------------------------- method `get_system_metrics` not found for this struct
    |
help: there is a method `get_prometheus_metrics` with a similar name
    |
626 -         let final_system_metrics = manager.get_system_metrics().await;
626 +         let final_system_metrics = manager.get_prometheus_metrics().await;
    |

warning: unused import: `Digest`
  --> src\core\integrity_checker.rs:21:11
   |
21 | use md5::{Digest as Md5Digest, Md5};
   |           ^^^^^^

warning: unused import: `Digest`
  --> src\core\integrity_checker.rs:22:12
   |
22 | use sha1::{Digest as Sha1Digest, Sha1};
   |            ^^^^^^

warning: unused import: `Digest`
  --> src\core\integrity_checker.rs:23:12
   |
23 | use sha2::{Digest as Sha2Digest, Sha256, Sha512};
   |            ^^^^^^

warning: unused import: `futures_util::StreamExt`
  --> src\core\m3u8_downloader.rs:14:5
   |
14 | use futures_util::StreamExt;
   |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `AsyncReadExt`
  --> src\core\resume_downloader.rs:22:17
   |
22 | use tokio::io::{AsyncReadExt, AsyncSeekExt, AsyncWriteExt, SeekFrom};
   |                 ^^^^^^^^^^^^

warning: unused variable: `width`
   --> src\commands\youtube.rs:521:29
    |
521 | fn determine_quality_string(width: Option<u32>, height: Option<u32>, format_id: &str) -> String {
    |                             ^^^^^ help: if this is intentional, prefix it with an underscore: `_width`

warning: unreachable pattern
   --> src\core\file_parser.rs:319:17
    |
316 |                 '\u{0000}'..='\u{007F}' => ascii_count += 1,
    |                 ----------------------- matches all the relevant values
...
319 |                 '\u{0000}'..='\u{001F}' => control_count += 1, // 鎺у埗瀛楃
    |                 ^^^^^^^^^^^^^^^^^^^^^^^ no value can reach this
    |
    = note: `#[warn(unreachable_patterns)]` on by default

warning: unused variable: `integrity_config`
   --> src\core\manager.rs:269:13
    |
269 |         let integrity_config = IntegrityConfig {
    |             ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_integrity_config`

warning: unused variable: `performance_metrics`
   --> src\core\monitoring.rs:948:9
    |
948 |         performance_metrics: &PerformanceMetrics,
    |         ^^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_performance_metrics`

warning: unused variable: `downloader`
   --> src\core\resume_downloader_integration_tests.rs:237:14
    |
237 |         let (downloader, _temp_dir) = create_test_downloader().await;
    |              ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_downloader`

warning: unused variable: `stats_big5`
   --> src\core\file_parser_integration_tests.rs:118:28
    |
118 |         let (records_big5, stats_big5) = parser.parse_file(&test_files.csv_big5).await.unwrap();
    |                            ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_stats_big5`

warning: unused variable: `download_result`
   --> src\core\youtube_downloader_integration_tests.rs:454:13
    |
454 |         let download_result = downloader
    |             ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_download_result`

error[E0382]: borrow of moved value: `result`
   --> src\core\youtube_downloader_integration_tests.rs:457:17
    |
444 |         let result = downloader
    |             ------ move occurs because `result` has type `Result<youtube_downloader::YoutubeVideoInfo, models::AppError>`, which does not implement the `Copy` trait
...
448 |         assert!(result
    |                 ------ help: consider calling `.as_ref()` or `.as_mut()` to borrow the type's contents
449 |             .unwrap_err()
    |              ------------ `result` moved due to this method call
...
457 |         assert!(result.is_err());
    |                 ^^^^^^ value borrowed here after move
    |
note: `Result::<T, E>::unwrap_err` takes ownership of the receiver `self`, which moves `result`
   --> /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2\library\core\src\result.rs:1256:23
help: you could `clone` the value and consume it, if the `models::AppError: Clone` trait bound could be satisfied
    |
448 |         assert!(result.clone()
    |                       ++++++++

error[E0716]: temporary value dropped while borrowed
   --> src\core\youtube_downloader_integration_tests.rs:501:18
    |
501 |                 &format!("concurrent-test-{}.mp4", i),
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ creates a temporary value which is freed while still in use
502 |             );
    |              - temporary value is freed at the end of this statement
503 |             download_futures.push(future);
    |                                   ------ borrow later used here
    |
    = note: consider using a `let` binding to create a longer lived value
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
  --> src\core\monitoring_integration_tests.rs:47:38
   |
47 |             system_metrics_interval: Duration::from_millis(100),
   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `Duration`

error[E0308]: mismatched types
  --> src\core\monitoring_integration_tests.rs:76:38
   |
76 |             download_stats_interval: Duration::from_millis(100),
   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `Duration`

error[E0308]: mismatched types
   --> src\core\monitoring_integration_tests.rs:148:38
    |
148 |             system_metrics_interval: Duration::from_millis(50),
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `Duration`

error[E0308]: mismatched types
   --> src\core\monitoring_integration_tests.rs:225:38
    |
225 |             download_stats_interval: Duration::from_millis(50),
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `Duration`

error[E0308]: mismatched types
   --> src\core\monitoring_integration_tests.rs:265:38
    |
265 |             system_metrics_interval: Duration::from_millis(50),
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `Duration`

error[E0308]: mismatched types
   --> src\core\system_integration_tests.rs:348:31
    |
348 |             output_directory: test_config.downloads_dir.clone(),
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found `PathBuf`

error[E0308]: mismatched types
   --> src\core\system_integration_tests.rs:391:31
    |
391 |             output_directory: test_config.downloads_dir.clone(),
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found `PathBuf`

error[E0308]: mismatched types
   --> src\core\system_integration_tests.rs:455:31
    |
455 |             output_directory: test_config.downloads_dir.clone(),
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found `PathBuf`

Some errors have detailed explanations: E0061, E0063, E0277, E0282, E0283, E0308, E0382, E0502, E0560...
For more information about an error, try `rustc --explain E0061`.
warning: `video-downloader-pro` (lib test) generated 106 warnings
error: could not compile `video-downloader-pro` (lib test) due to 345 previous errors; 106 warnings emitted
