# Download Concurrency & Pause/Resume Repair Plan

## 用户反馈的现象
- 并发设置为 3，但点击“开始下载”时只启动了 1 条任务。
- 点击暂停后无法再次启动；多次刷新/开始后状态随机，无法恢复到正确的暂停/继续位置。
- 期望：并发数严格生效；暂停的任务可恢复且保持幂等；同一表格再次导入时能识别已下载/半下载的任务并续传。

## 代码侧主要发现
- `DownloadManager` 只在启动/暂停/取消时修改任务状态；**完成/失败时不更新内部任务列表，也不移除 `active_downloads`**。`get_download_tasks` 返回的状态与事件不一致，前端刷新后覆盖了事件状态，导致前端并发队列判断一直认为有下载中的任务，卡住后续启动。
- 事件桥（`main.rs` 中的 channel -> Tauri emit）**只转发事件给前端，没有回写后台状态**；后台任务进度/完成信息没有落盘到内存模型。
- 进度事件未写回 `tasks`，`refreshTasks` 会把前端的进度重置为 0；完成后也没有写入 `downloaded_size`/`file_size`，影响后续幂等恢复的准确性。
- `active_downloads` 中的 `JoinHandle` 在完成/失败后未移除，统计信息一直认为有活跃下载，进一步放大前端并发槽位计算的误差。

## 修复思路
1. **事件驱动的状态同步**：为 `DownloadManager` 增加“根据事件更新状态”的公共方法，覆盖进度、完成、失败、暂停/恢复等，统一写入 `tasks`（状态、进度、速度、eta、文件大小）、清理 `active_downloads`、并刷新统计。
2. **事件桥回写状态**：在 `main.rs` 的事件桥中，在转发到前端之前调用上述同步方法，保证后端 `get_download_tasks`/`get_download_stats` 与事件一致，避免前端刷新覆盖正确状态。
3. **完成/失败清理**：在完成/失败/取消时清理 `active_downloads`，并从文件元数据回填 `downloaded_size`/`file_size`，将进度置为 100%/保持当前。
4. **前后端状态一致性**：保持进度单位统一为百分比（0-100）写入任务，防止刷新后进度被重置；确保状态变化会触发统计刷新和并发槽释放。

## 任务拆解
1) 在后端添加任务生命周期同步工具方法（进度/完成/失败/暂停/恢复），确保更新任务字段和统计并清理活跃句柄。  
2) 将事件桥接逻辑接入上述方法，在发送到前端前先更新后端状态。  
3) 复查前端并发队列与状态同步（如需微调保持一致性），并做基本流程冒烟验证（启动 3 条、暂停/恢复、刷新后继续、重复导入的幂等性）。
