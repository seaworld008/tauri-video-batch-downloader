# 下载调度总览（2024-12-04）

## 1. 背景与问题
- 导入任务后尚未点击“开始”就自动下载，且顺序不可控。
- 暂停任务后数秒会自动恢复，甚至伴随其它任务随机启动。
- “开始全部”按钮无法保证按列表顺序依次下载，也难以与断点续传场景对齐。
- 前端虽然维护了 `pendingStartQueue`，但后端的 `FillSlots` 后台调度会绕过队列，导致状态错乱。

## 2. 设计目标
1. **完全手动控制**：只有用户显式点击“开始/恢复”后，任务才允许进入调度队列。
2. **确定性的顺序**：并发槽位释放后，新的任务按照队列顺序（默认即 UI 的从上到下顺序）补位。
3. **稳定的暂停/恢复**：暂停任务立即从队列剔除；只有再次点击“恢复”才会重新入队。
4. **可恢复的导入**：当导入历史任务或新任务指向已存在文件时，可以复用本地进度（在后续阶段通过哈希检测实现）。
5. **性能可预期**：调度循环不再轮询，仅在任务状态变更或显式入队时触发，降低后台噪声。

## 3. 新的职责分工

| 层级 | 角色 | 主要职责 |
| --- | --- | --- |
| React Store (`downloadStore.ts`) | 队列主控器 | 维护 `pendingStartQueue`，按顺序（先进先出 + 手动恢复优先）触发 `start_download` 命令 |
| Tauri Commands (`start_download`, `pause_download`, …) | 执行器 | 负责实际的下载启动/暂停，保持接口幂等 |
| Download Manager (Rust) | 下载核心 | 负责单任务生命周期、进度、重试、事件上报；**不再主动填充并发槽位** |
| Event Bridge (`task_status_changed`) | 状态信号 | 每当任务状态变化时通知前端并触发队列再调度 |

## 4. 关键流程

### 4.1 入队与开始
1. 用户点击“开始”；
2. `start_download` 若并发未满 → 直接启动；
3. 若返回并发限制错误，前端把任务 ID 追加到 `pendingStartQueue`（保持用户点击顺序）；
4. `processStartQueue` 监听 `task_status_changed` 或显式调用，检查空闲槽位并依序启动。

### 4.2 暂停
1. 用户点击“暂停”；
2. 任务从 `pendingStartQueue` 中移除；
3. `resumePriority` 记录该任务 ID，以便未来“恢复”可插入队首；
4. 后端停止下载，任务状态变为 `paused`，不会再被自动启动。

### 4.3 恢复
1. 用户点击“恢复”；
2. 若并发未满 → 立即恢复；
3. 若仍超限 → 将任务 ID 插入队列头部（保持优先级），等待下一次 `processStartQueue`。

### 4.4 导入历史/断点续传
目前阶段仅在前端保持任务顺序及状态；后续通过在 `add_video_task` 阶段检测目标目录下的完整/半成品文件来决定是否标记为 `completed` 或 `paused`，并在 `start_download` 前执行断点续传。该能力在下一次迭代中落地。

## 5. 变更摘要
1. **停止后端 FillSlots**：删除 `RuntimeCommand::FillSlots` 及其定时器，避免后台自动启动任务。
2. **前端队列线性化**：
   - `processStartQueue` 不再对队列排序，严格按照用户入队顺序执行；
   - 过滤条件只排除 `completed/cancelled/downloading`，允许 `paused/failed/pending` 在用户显式入队后被调度；
   - `startAllDownloads` 统一使用前端队列，彻底移除对 `start_all_pending_downloads` 的依赖。
3. **状态驱动调度**：`task_status_changed` 监听器在收到任何状态变更后都会触发 `processStartQueue`，以最快速度填充空闲并发槽位。
4. **顺序一致性**：恢复任务通过 `resumePriority` 插入队列头；普通任务保持 FIFO，满足“列表顺序开始”的要求。

## 6. 后续计划
- **断点续传检测**：在 `add_video_task` 期间根据 URL/文件名映射检查已存在文件、`.partial` 文件，并更新 `downloaded_size` 及状态。
- **后端队列持久化**：若今后需要 CLI 或多前端同时控制下载，可将当前的队列逻辑下沉至 Rust 层，并通过命令接口暴露。
- **队列可视化**：在 UI 中显示“排队中”列表与位置，帮助用户理解即将启动的任务。

> 本文档与实现同步，若调度策略再有演进，请更新此文档并在 README 中引用。
